
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>m4 support in Opbasm &#8212; Opbasm 1.3.10 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" href="../_static/project.css" type="text/css" />
    <link rel="stylesheet" href="../_static/tty/tty-player.min.css" type="text/css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="PicoBlaze architecture reference" href="language.html" />
    <link rel="prev" title="Open PicoBlaze Assembler" href="../index.html" />

   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

<script src="_static/tty/webcomponents-lite.min.js"></script>
<script src="_static/tty/term.min.js"></script>
<script src="_static/tty/tty-player.min.js"></script>

<style>
	.terminal-cursor {
		color: #000;
		background: green;
	}
	.terminal, .title {
		font-size:x-small;
	}
</style>


  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="m4-support-in-opbasm">
<h1>m4 support in Opbasm<a class="headerlink" href="#m4-support-in-opbasm" title="Permalink to this heading">¶</a></h1>
<p>The m4 preprocessor adds powerful facilities for enhanced PicoBlaze assembly. m4 is typically already present on most Linux systems. A precompiled Windows binary is included with Opbasm. Opbasm will automatically run m4 if a source file has the extension “.psm4” or “.m4” or on any file if the <code class="docutils literal notranslate"><span class="pre">--m4</span></code> option is used. The included macro package depends on some GNU extensions so GNU m4 must be used if the built-in macros are employed.</p>
<p>Around 200 predefined macros are provided with Opbasm covering the following areas:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><ul class="simple">
<li><p><a class="reference internal" href="#id1">Stack operations</a></p></li>
<li><p><a class="reference internal" href="#bitfield-manipulations">Bitfield manipulations</a></p></li>
<li><p><a class="reference internal" href="#shift-and-rotate-by-multiple-bits">Shift and rotate by multiple bits</a></p></li>
<li><p><a class="reference internal" href="#conditional-jump-call-and-return">Conditional jump, call, and return</a></p></li>
<li><p><a class="reference internal" href="#conditional-if-then-else">Conditional if-then-else</a></p></li>
<li><p><a class="reference internal" href="#looping">Looping</a></p></li>
<li><p><a class="reference internal" href="#procedures-and-functions">Procedures and functions</a></p></li>
<li><p><a class="reference internal" href="#delay-generators">Delay generators</a></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><a class="reference internal" href="#string-and-table-operations">String and table operations</a></p></li>
<li><p><a class="reference internal" href="#scratchpad-memory-operations">Scratchpad memory operations</a></p></li>
<li><p><a class="reference internal" href="#bcd-conversion">BCD conversion</a></p></li>
<li><p><a class="reference internal" href="#bit-arithmetic-logical-and-shift-operators">16-bit arithmetic, logical, and shift operators</a></p></li>
<li><p><a class="reference internal" href="#bit-i-o-operations">16-bit I/O operations</a></p></li>
<li><p><a class="reference internal" href="#multiply-and-divide-routines">Multiply and divide routines</a></p></li>
<li><p><a class="reference internal" href="#expressions">Expressions</a></p></li>
<li><p><a class="reference internal" href="#random-numbers">Random numbers</a></p></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>None of the macros use the PicoBlaze-6 inactive bank registers. They are all portable to both targets although a few lose some functionality on PicoBlaze-3.</p>
<p>Using these macros you can write code in a higher-level style like the following Fibonacci generator.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>With macros:</p></th>
<th class="head"><p>After expansion:</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nl">fibonacci:</span>
  <span class="c">; Generate the first 10 Fibonacci numbers</span>
  <span class="nb">vars(</span><span class="s">s0</span> <span class="s">is</span> <span class="s">counter</span><span class="p">,</span> <span class="s">s1</span> <span class="s">is</span> <span class="s">two_prev</span> <span class="o">:=</span> <span class="m">0</span><span class="p">,</span>
      <span class="s">s2</span> <span class="s">is</span> <span class="s">prev</span> <span class="o">:=</span> <span class="m">1</span><span class="p">,</span> <span class="s">s3</span> <span class="s">is</span> <span class="s">next</span><span class="nb">)</span>
  <span class="nb">for (</span><span class="s">counter</span> <span class="o">:=</span> <span class="m">0</span><span class="p">,</span> <span class="s">counter</span> <span class="o">&lt;</span> <span class="m">10</span><span class="p">,</span> <span class="s">counter</span> <span class="o">:=</span> <span class="s">counter</span> <span class="o">+</span> <span class="m">1</span><span class="nb">)</span> <span class="p">{</span>
   <span class="nb">if (</span><span class="s">counter</span> <span class="o">&lt;</span> <span class="m">2</span><span class="nb">)</span> <span class="p">{</span>
     <span class="k">LOAD</span> <span class="n">next</span><span class="p">,</span> <span class="n">counter</span>
   <span class="p">}</span> <span class="nb">else</span> <span class="p">{</span>
     <span class="c">; Compute next number</span>
     <span class="nb">expr(</span><span class="s">next</span> <span class="o">:=</span> <span class="s">two_prev</span> <span class="o">+</span> <span class="s">prev</span><span class="nb">)</span>
     <span class="k">LOAD</span> <span class="n">two_prev</span><span class="p">,</span> <span class="n">prev</span>
     <span class="k">LOAD</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span>
   <span class="p">}</span>
   <span class="nb">push(</span><span class="s">next</span><span class="nb">)</span>
   <span class="k">CALL</span> <span class="n">print_num</span>   <span class="c">; Output the next number</span>
  <span class="p">}</span>
  <span class="k">RETURN</span>
</pre></div>
</div>
</td>
<td><div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span>      <span class="nl">fibonacci:</span>
                 <span class="c">; Generate the first 10 Fibonacci numbers</span>
                 <span class="k">LOAD</span> <span class="n">s1</span><span class="p">,</span> <span class="mh">00</span>          <span class="c">; Var two_prev := 0</span>
                 <span class="k">LOAD</span> <span class="n">s2</span><span class="p">,</span> <span class="mh">01</span>          <span class="c">; Var prev := 1</span>
                 <span class="c">; Expression: s0 := 0</span>
                 <span class="k">LOAD</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">00</span>

    <span class="nl">FOR_f1_0001:</span>
                 <span class="c">; If s0 &lt; 10</span>
                 <span class="k">COMPARE</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">0a</span>
                 <span class="k">JUMP</span> <span class="n">nc</span><span class="p">,</span> <span class="n">GE_f1_0004</span>

                 <span class="c">; If s0 &lt; 2</span>
                 <span class="k">COMPARE</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">02</span>
                 <span class="k">JUMP</span> <span class="n">nc</span><span class="p">,</span> <span class="n">GE_f1_0006</span>
                 <span class="k">LOAD</span> <span class="n">s3</span><span class="p">,</span> <span class="n">s0</span>
                 <span class="k">JUMP</span> <span class="n">ENDIF_f1_0007</span>

     <span class="nl">GE_f1_0006:</span>
                 <span class="c">; Compute next number</span>
                 <span class="c">; Expression: s3 := s1 + s2</span>
                 <span class="k">LOAD</span> <span class="n">s3</span><span class="p">,</span> <span class="n">s1</span>
                 <span class="k">ADD</span> <span class="n">s3</span><span class="p">,</span> <span class="n">s2</span>
                 <span class="k">LOAD</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span>
                 <span class="k">LOAD</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s3</span>

  <span class="nl">ENDIF_f1_0007:</span>
                 <span class="k">STORE</span> <span class="n">s3</span><span class="p">,</span> <span class="p">(</span><span class="n">sf</span><span class="p">)</span>       <span class="c">; Push</span>
                 <span class="k">SUB</span> <span class="n">sf</span><span class="p">,</span> <span class="mh">01</span>
                 <span class="k">CALL</span> <span class="n">print_num</span>       <span class="c">; Output the next number</span>

<span class="nl">NEXTFOR_f1_0002:</span>
                 <span class="c">; Expression: s0 := s0 + 1</span>
                 <span class="k">ADD</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">01</span>
                 <span class="k">JUMP</span> <span class="n">FOR_f1_0001</span>
     <span class="nl">GE_f1_0004:</span>
<span class="nl">ENDLOOP_f1_0003:</span>
                 <span class="k">RETURN</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<section id="installing-m4-on-windows">
<span id="guidance-on-installing-m4-under-windows"></span><h2>Installing m4 on Windows<a class="headerlink" href="#installing-m4-on-windows" title="Permalink to this heading">¶</a></h2>
<p>Opbasm includes GnuWin32 Windows binaries for <a class="reference external" href="http://gnuwin32.sourceforge.net/packages/m4.htm">m4</a>. It will be installed by the setup.py script.</p>
<p>In the Cygwin environment, the included binary will not be executed and you must install the Cygwin version of m4. In the <a class="reference external" href="http://cygwin.com/install.html">Cygwin installer</a> select the m4 package (under Interpreters) for installation. Opbasm will be able to use m4 immediately within a Cygwin shell.</p>
</section>
<section id="overview-of-m4">
<h2>Overview of m4<a class="headerlink" href="#overview-of-m4" title="Permalink to this heading">¶</a></h2>
<p>m4 is a general purpose macro preprocessor. It performs text based string manipulation through repeated expansion of previously defined macros including support for recursion. The preprocessor has a number of built in macros and provides a means to define your own. Macros have a name that contains letters, digits, and underscores. Any arguments are enclosed in parentheses and delimited by commas. Expansion is suppressed by enclosing text in quote characters which are <code class="docutils literal notranslate"><span class="pre">`'</span></code> by default. Comments start with “#” by default but have been changed to use “;” to match PicoBlaze syntax.</p>
<p>m4 uses different syntax from PicoBlaze assembly to represent different types of literals. It is important to know what context you are operating in to determine which type of literal to put in your source.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Type</p></th>
<th class="head"><p>PicoBlaze</p></th>
<th class="head"><p>m4</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Decimal</p></td>
<td><p>10’d</p></td>
<td><p>10</p></td>
</tr>
<tr class="row-odd"><td><p>Hexadecimal</p></td>
<td><p>0a</p></td>
<td><p>0x0a</p></td>
</tr>
<tr class="row-even"><td><p>Binary</p></td>
<td><p>00001010’b</p></td>
<td><p>0b1010</p></td>
</tr>
<tr class="row-odd"><td><p>Char</p></td>
<td><p>“A”</p></td>
<td><p>A or <code class="docutils literal notranslate"><span class="pre">`A'</span></code></p></td>
</tr>
</tbody>
</table>
<p>In general you use m4 syntax for literals passed as arguments to macros within parentheses. The only exception is <a class="reference internal" href="library.html#pb.pbhex" title="pbhex"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">pbhex()</span></code></a> which takes a list of hex values in PicoBlaze format. Be careful not to use PicoBlaze hex format in other m4 contexts as it will be misinterpreted as decimal if only digits 0-9 are used.</p>
<p>m4 includes the ability to evaluate arbitrary integer expressions using the builtin <code class="docutils literal notranslate"><span class="pre">eval()</span></code> macro. Its default output is an m4 decimal integer so the similar <a class="reference internal" href="library.html#pb.evalh" title="evalh"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">evalh()</span></code></a>, <a class="reference internal" href="library.html#pb.evald" title="evald"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">evald()</span></code></a>, and <a class="reference internal" href="library.html#pb.evalb" title="evalb"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">evalb()</span></code></a> are provided to evaluate expressions resulting in PicoBlaze hex, decimal, or binary format.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="nb">evald(</span><span class="m">4</span> <span class="o">*</span> <span class="m">5</span> <span class="o">+</span> <span class="m">1</span><span class="nb">)</span>     <span class="c">; Expands to &quot;load s0, 21&#39;d&quot;</span>
</pre></div>
</div>
<p>The expression evaluator permits the natural use of negative decimal literals:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="nb">evalh(</span><span class="o">-</span><span class="m">20</span><span class="nb">)</span>           <span class="c">; Expands to &quot;load s0, ec&quot;</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="library.html#pb.evala" title="evala"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">evala()</span></code></a> macro works like <a class="reference internal" href="library.html#pb.evalh" title="evalh"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">evalh()</span></code></a> but expands to a 12-bit PicoBlaze address.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">define(</span><span class="s">DATA_ORG</span><span class="p">,</span> <span class="mh">0x200</span><span class="nb">)</span>
<span class="k">address</span> <span class="nb">evala(</span><span class="s">DATA_ORG</span><span class="nb">)</span>       <span class="c">; Expands to &quot;address 200&quot;</span>
</pre></div>
</div>
<p>m4 expressions support all of the C language operators as well as <code class="docutils literal notranslate"><span class="pre">**</span></code> for exponentiation.</p>
<p>Note that <a class="reference internal" href="library.html#pb.evalh" title="evalh"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">evalh()</span></code></a>, <a class="reference internal" href="library.html#pb.evald" title="evald"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">evald()</span></code></a>, and <a class="reference internal" href="library.html#pb.evalb" title="evalb"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">evalb()</span></code></a> cannot be nested within other macros because they expand with a comment reporting the original expression to make the listing file easier to read. If you need to evaluate an expression within another macro you should use the builtin <code class="docutils literal notranslate"><span class="pre">eval()</span></code> macro. Of particular note it is important to know that Picoblaze <a class="reference internal" href="language.html#inst-constant"><span class="std std-ref">constant</span></a> directives are temporarily converted into an undocumented <code class="docutils literal notranslate"><span class="pre">const()</span></code> macro so that constants defined in Picoblaze syntax are accessible to m4. As a consequence you can’t use the custom eval macros that generate a comment to compute a constant value.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">constant</span> <span class="n">BAD_CONST</span><span class="p">,</span>  <span class="nb">evalh(</span><span class="m">1</span><span class="o">+</span><span class="m">1</span><span class="nb">)</span>       <span class="c">; This will fail during m4 expansion</span>
<span class="k">constant</span> <span class="n">GOOD_CONST</span><span class="p">,</span> <span class="nb">eval(</span><span class="m">1</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="m">16</span><span class="p">,</span> <span class="m">2</span><span class="nb">)</span> <span class="c">; Generate zero-padded hex constant</span>
</pre></div>
</div>
<p>An <a class="reference internal" href="library.html#pb.evalx" title="evalx"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">evalx()</span></code></a> macro is available which works like the builtin <code class="docutils literal notranslate"><span class="pre">eval()</span></code> but also accepts strings that are not valid expressions.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="nb">evalx(</span><span class="m">9</span> <span class="o">+</span> <span class="m">2</span><span class="p">,</span> <span class="m">16</span><span class="p">,</span> <span class="m">2</span><span class="nb">)</span>  <span class="c">; Expands to &quot;load s0, 0b&quot;</span>
<span class="k">constant</span> <span class="n">CNAME</span><span class="p">,</span> <span class="mh">1f</span>
<span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="nb">evalx(</span><span class="s">CNAME</span><span class="nb">)</span>         <span class="c">; Expands to &quot;load s0, CNAME&quot;</span>
</pre></div>
</div>
<p id="m4-define">You can define aliases for registers without altering the original as with <a class="reference internal" href="language.html#inst-namereg"><span class="std std-ref">namereg</span></a>.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">define(</span><span class="s">alt_name</span><span class="p">,</span> <span class="s">s0</span><span class="nb">)</span>
<span class="k">load</span> <span class="n">alt_name</span><span class="p">,</span> <span class="mh">01</span>             <span class="c">; Expands to &quot;load s0, 01&quot;</span>
<span class="k">add</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">01</span>                    <span class="c">; s0 register is still visible</span>
</pre></div>
</div>
<p>Special logic is implemented in a preprocessor stage so that PicoBlaze constants are visible to m4. They are automatically converted from PicoBlaze format into m4 format.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">constant</span> <span class="n">THE_ANSWER</span><span class="p">,</span> <span class="m">42&#39;d</span>
<span class="nb">expr(</span><span class="s">s0</span> <span class="o">:=</span> <span class="s">s1</span> <span class="o">+</span> <span class="s">THE_ANSWER</span><span class="nb">)</span>                            <span class="c">; Same as expr(s0 := s1 + 42)</span>
<span class="nb">if(</span><span class="s">s0</span> <span class="o">&gt;</span> <span class="s">THE_ANSWER</span><span class="p">,</span> <span class="s">`output</span> <span class="s">s1</span><span class="p">,</span> <span class="m">00</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">`output</span> <span class="s">s2</span><span class="p">,</span> <span class="m">00</span><span class="s">&#39;</span><span class="nb">)</span>  <span class="c">; Left operand is treated like a constant</span>
</pre></div>
</div>
<p>You can use also use <code class="docutils literal notranslate"><span class="pre">define()</span></code> to establish constants that are visible to m4 and create more complex macros. <a class="reference external" href="http://mbreen.com/m4.html">Michael Breen’s notes on m4</a> provide a good introductory overview to m4. The <a class="reference external" href="https://www.gnu.org/savannah-checkouts/gnu/m4/manual/">Gnu m4 manual</a> provides more detailed documentation.</p>
</section>
<section id="type-conversions">
<h2>Type conversions<a class="headerlink" href="#type-conversions" title="Permalink to this heading">¶</a></h2>
<p>Some basic macros are provided to perform type conversions. They are useful for constructing parameters to other macros that only expect decimal values.</p>
<p>The <a class="reference internal" href="library.html#pb.pbhex" title="pbhex"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">pbhex()</span></code></a> macro is used to convert a list of values in PicoBlaze hex format into m4 decimals.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">pbhex(</span><span class="mh">0a</span><span class="p">,</span> <span class="mh">0b</span><span class="p">,</span> <span class="mh">ff</span><span class="nb">)</span>         <span class="c">; Expands to &quot;10, 11, 255&quot;</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="library.html#pb.asciiord" title="asciiord"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">asciiord()</span></code></a> macro converts a string of one or more characters to a list of decimals representing their ASCII encoding. Quotes are not strictly necessary but guard against including trailing whitespace.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">asciiord(</span><span class="m">0</span><span class="nb">)</span>               <span class="c">; Expands to &quot;48&quot;</span>
<span class="nb">asciiord(</span><span class="s">`any</span> <span class="s">str&#39;</span><span class="nb">)</span>       <span class="c">; Expands to &quot;97, 110, 121, 32, 115, 116, 114&quot;</span>
</pre></div>
</div>
<p>If you need a NUL terminated string, the <a class="reference internal" href="library.html#pb.cstr" title="cstr"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">cstr()</span></code></a> macro works the same but appends a terminating 0:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">cstr(</span><span class="s">`1234&#39;</span><span class="nb">)</span>     <span class="c">; Expands to &quot;49, 50, 51, 52, 0&quot;</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="library.html#pb.words_le" title="words_le"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">words_le()</span></code></a> and <a class="reference internal" href="library.html#pb.words_be" title="words_be"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">words_be()</span></code></a> macros convert a list of 16-bit numbers into little-endian or big-endian bytes.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">words_le(</span><span class="mh">0xff01</span><span class="p">,</span> <span class="mh">0xff02</span><span class="nb">)</span>  <span class="c">; Expands to &quot;1, 255, 2, 255&quot;</span>
<span class="nb">words_be(</span><span class="mh">0xff01</span><span class="p">,</span> <span class="mh">0xff02</span><span class="nb">)</span>  <span class="c">; Expands to &quot;255, 1, 255, 2&quot;</span>
</pre></div>
</div>
</section>
<section id="conditional-code">
<span id="m4-conditional-code"></span><h2>Conditional code<a class="headerlink" href="#conditional-code" title="Permalink to this heading">¶</a></h2>
<p>You may want to conditionally generate portions of a program or pass build time parameters to macros for different results. This can be accomplished with the m4 <code class="docutils literal notranslate"><span class="pre">ifdef()</span></code> macro.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">ifdef(</span><span class="s">`VARNAME`</span><span class="p">,</span> <span class="s">`</span>
  <span class="o">&lt;</span><span class="s">Defined</span> <span class="s">conditional</span> <span class="s">code</span> <span class="s">here</span><span class="o">&gt;</span>
<span class="s">&#39;</span><span class="p">,</span> <span class="s">`</span>
  <span class="o">&lt;</span><span class="s">Undefined</span> <span class="s">conditional</span> <span class="s">code</span> <span class="s">here</span><span class="o">&gt;</span>
<span class="s">&#39;</span><span class="nb">)</span>


<span class="nb">ifdef(</span><span class="s">`VARNAME&#39;</span><span class="p">,</span> <span class="s">`load</span> <span class="s">s0</span><span class="p">,</span> <span class="m">10</span><span class="s">&#39;</span><span class="nb">)</span>  <span class="c">; Defined</span>

<span class="nb">ifdef(</span><span class="s">`VARNAME&#39;</span><span class="p">,,</span> <span class="s">`load</span> <span class="s">s0</span><span class="p">,</span> <span class="m">20</span><span class="s">&#39;</span><span class="nb">)</span> <span class="c">; Not defined</span>

<span class="k">load</span> <span class="n">s1</span><span class="p">,</span> <span class="n">MAXVAL</span>
</pre></div>
</div>
<p>You can omit either block of the <code class="docutils literal notranslate"><span class="pre">ifdef()</span></code> macro if you want generation only for the defined or undefined conditions. To control the selected code block you pass defined variables with the <code class="docutils literal notranslate"><span class="pre">-D</span></code> option to Opbasm:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">opbasm -DVARNAME -DMAXVAL=42 foo.psm4</span>
</pre></div>
</div>
<p>This will define “VARNAME” as an empty string and “MAXVAL” with the string “42” which will be passed on unaltered to the assembler. These defined variables become macros which will be substituted with their value like any other macro.</p>
</section>
<section id="general-purpose-macros">
<h2>General purpose macros<a class="headerlink" href="#general-purpose-macros" title="Permalink to this heading">¶</a></h2>
<p>A few of the macros depend on modifying a temporary register. To simplify the macro calls, a preallocated temp register is used. It is set to <cite>sE</cite> by default. You can change it to another register by calling <a class="reference internal" href="library.html#pb.use_tempreg" title="use_tempreg"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_tempreg()</span></code></a>. The temp register can be accessed in your own macros by using the <code class="docutils literal notranslate"><span class="pre">_tempreg</span></code> macro. The temp register is never preserved on the stack and you should not store data you want preserved across invocations of Opbasm macros.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">use_tempreg(</span><span class="s">sA</span><span class="nb">)</span>    <span class="c">; Switch to sA for the temp register</span>
</pre></div>
</div>
<p>The following macros use the temp register:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>expr2s</p></td>
<td><p>load_out</p></td>
<td><p>load_store</p></td>
<td><p>setcy</p></td>
<td><p>use_multiply8x8</p></td>
</tr>
<tr class="row-even"><td><p>use_multiply8x8s</p></td>
<td><p>use_multiply8x8su</p></td>
<td><p>use_divide8x8</p></td>
<td><p>use_divide8x8s</p></td>
<td><p>use_divide16x8</p></td>
</tr>
<tr class="row-odd"><td><p>use_divide16x8s</p></td>
<td><p>use_divide8xk</p></td>
<td><p>use_random8</p></td>
<td><p>use_memcopy</p></td>
<td><p>use_memwrite</p></td>
</tr>
<tr class="row-even"><td><p>use_bcdwrite</p></td>
<td><p>use_hexwrite</p></td>
<td><p>use_int2bcd</p></td>
<td><p>use_ascii2bcd</p></td>
<td><p>use_bcd2int</p></td>
</tr>
</tbody>
</table>
<p>The other <a class="reference internal" href="library.html#pb.expr" title="expr"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">expr()</span></code></a> macros use the temp register indirectly when the mul and div operations are invoked.</p>
<p>You can guard against accidentally using the temp register for long term storage by renaming it with the <a class="reference internal" href="language.html#inst-namereg"><span class="std std-ref">namereg</span></a> directive:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">namereg</span> <span class="n">sE</span><span class="p">,</span> <span class="n">TEMPREG</span>
<span class="nb">use_tempreg(</span><span class="s">TEMPREG</span><span class="nb">)</span>
</pre></div>
</div>
<p>Now you can’t accidentally assign something to <code class="docutils literal notranslate"><span class="pre">sE</span></code> that will be overwritten by a macro using the <code class="docutils literal notranslate"><span class="pre">_tempreg</span></code> macro.</p>
<p>PicoBlaze programs commonly contain lists of constant declarations for IO port addresses. The <a class="reference internal" href="library.html#pb.iodefs" title="iodefs"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">iodefs()</span></code></a> macro simplifies their declaration by allowing contiguous sequences of ports to be named in one statement. It can also be used to define scratchpad addresses.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="c">; Usage: iodefs(&lt;start port&gt;, [port names]+)</span>
<span class="nb">iodefs(</span><span class="m">0</span><span class="p">,</span> <span class="s">P_control</span><span class="p">,</span> <span class="s">P_read</span><span class="p">,</span> <span class="s">P_write</span><span class="nb">)</span>

<span class="c">; Expands to:</span>
  <span class="k">constant</span> <span class="n">P_control</span><span class="p">,</span> <span class="mh">00</span>
  <span class="k">constant</span> <span class="n">P_read</span><span class="p">,</span> <span class="mh">01</span>
  <span class="k">constant</span> <span class="n">P_write</span><span class="p">,</span> <span class="mh">02</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="library.html#pb.vars" title="vars"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">vars()</span></code></a> macro allows you to associate alias names with a register. Unlike the <a class="reference internal" href="language.html#inst-namereg"><span class="std std-ref">namereg</span></a> directive, the original register name is still available. An optional initial value can be provided:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="c">; Usage: vars([&lt;reg&gt; is &lt;alias&gt; [:= &lt;init&gt;]]+)</span>
<span class="nb">vars(</span><span class="s">`s0</span> <span class="s">is</span> <span class="s">count</span> <span class="o">:=</span> <span class="m">0</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">`s1</span> <span class="s">is</span> <span class="s">sum&#39;</span><span class="nb">)</span>

<span class="c">; Expands to:</span>
  <span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">00</span>
</pre></div>
</div>
<p>Symbols “count” and “sum” can now be used in place of s0 and s1. You should quote each variable declaration to avoid macro expansion errors when redefining an existing variable. Use the <a class="reference internal" href="library.html#pb.popvars" title="popvars"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">popvars()</span></code></a> macro to remove all variables defined in the previous call to <a class="reference internal" href="library.html#pb.vars" title="vars"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">vars()</span></code></a>.</p>
</section>
<section id="stack-operations">
<span id="id1"></span><h2>Stack operations<a class="headerlink" href="#stack-operations" title="Permalink to this heading">¶</a></h2>
<p>A set of macros are available to simulate a stack using the scratchpad RAM. You initialize the stack and establish the stack pointer register with a call to <a class="reference internal" href="library.html#pb.use_stack" title="use_stack"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_stack()</span></code></a>. After that you can call <a class="reference internal" href="library.html#pb.push" title="push"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">push()</span></code></a> and <a class="reference internal" href="library.html#pb.pop" title="pop"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">pop()</span></code></a> to manage registers on the stack. You can push and pop any number of registers at once. Pops happen in reverse order to preserve register values when passed the same list as <a class="reference internal" href="library.html#pb.push" title="push"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">push()</span></code></a>. The stack grows down so the initial address should be the highest the stack will occupy.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">namereg</span> <span class="n">sF</span><span class="p">,</span> <span class="n">SP</span>      <span class="c">; Protect sF for use as the stack pointer</span>
<span class="nb">use_stack(</span><span class="s">SP</span><span class="p">,</span> <span class="mh">0x3F</span><span class="nb">)</span> <span class="c">; Start stack at end of 64-byte scratchpad</span>
...

<span class="nl">my_func:</span>
  <span class="nb">push(</span><span class="s">s0</span><span class="p">,</span> <span class="s">s1</span><span class="nb">)</span>
  <span class="ge">&lt;Do something that alters s0 and s1&gt;</span>
  <span class="nb">pop(</span><span class="s">s0</span><span class="p">,</span> <span class="s">s1</span><span class="nb">)</span>
  <span class="k">return</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="library.html#pb.getstack" title="getstack"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">getstack()</span></code></a>, <a class="reference internal" href="library.html#pb.getstackat" title="getstackat"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">getstackat()</span></code></a>, and <a class="reference internal" href="library.html#pb.dropstack" title="dropstack"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">dropstack()</span></code></a> macros can be used to retrieve and drop values from a stack frame. This provides a facility for passing function arguments on the stack and is particularly useful for writing functions that take a variable number of arguments. The argument to <a class="reference internal" href="library.html#pb.dropstack" title="dropstack"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">dropstack()</span></code></a> can be a register to drop a variable number of arguments.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span>  <span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">BE</span>
  <span class="nb">push(</span><span class="s">s0</span><span class="nb">)</span>    <span class="c">; First argument</span>
  <span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">EF</span>
  <span class="nb">push(</span><span class="s">s0</span><span class="nb">)</span>    <span class="c">; Second argument</span>
  <span class="k">call</span> <span class="n">my_func2</span>

<span class="nl">my_func2:</span>
  <span class="nb">getstack(</span><span class="s">s3</span><span class="p">,</span> <span class="s">s4</span><span class="nb">)</span>     <span class="c">; Retrieve first and second argument</span>
  <span class="ge">&lt;Do your business&gt;</span>
  <span class="nb">dropstack(</span><span class="m">2</span><span class="nb">)</span>         <span class="c">; Remove arguments from the stack</span>
  <span class="k">return</span>
</pre></div>
</div>
<p>You can use the <a class="reference internal" href="library.html#pb.getstackat" title="getstackat"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">getstackat()</span></code></a> macro to retrieve values from the stack one at a time in any order.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nl">my_func3:</span>
  <span class="nb">getstackat(</span><span class="s">s4</span><span class="p">,</span> <span class="m">1</span><span class="nb">)</span>    <span class="c">; Retrieve second argument (SP + 1)</span>
  <span class="nb">getstackat(</span><span class="s">s3</span><span class="p">,</span> <span class="m">2</span><span class="nb">)</span>    <span class="c">; Retrieve first argument  (SP + 2)</span>
  <span class="ge">&lt;Do your business&gt;</span>
  <span class="nb">dropstack(</span><span class="m">2</span><span class="nb">)</span>         <span class="c">; Remove arguments from the stack</span>
  <span class="k">return</span>
</pre></div>
</div>
<p>You may wish to allocate temporary space on the stack for local variables in a function. Use the <a class="reference internal" href="library.html#pb.addstack" title="addstack"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">addstack()</span></code></a> macro to accomplish this. <a class="reference internal" href="library.html#pb.putstack" title="putstack"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">putstack()</span></code></a> and <a class="reference internal" href="library.html#pb.putstackat" title="putstackat"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">putstackat()</span></code></a> are used to store register values on the stack without altering the stack pointer.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nl">my_func4:</span>
  <span class="nb">addstack(</span><span class="m">4</span><span class="nb">)</span>              <span class="c">; Add 4 bytes to the stack to work with</span>
  <span class="nb">putstack(</span><span class="s">s0</span><span class="p">,</span> <span class="s">s1</span><span class="p">,</span> <span class="s">s2</span><span class="p">,</span> <span class="s">s3</span><span class="nb">)</span>
  <span class="nb">getstackat(</span><span class="s">s4</span><span class="p">,</span> <span class="m">2</span><span class="nb">)</span>
  <span class="nb">dropstack(</span><span class="m">4</span><span class="nb">)</span>             <span class="c">; Remove local frame</span>
</pre></div>
</div>
</section>
<section id="bitfield-operations">
<span id="bitfield-manipulations"></span><h2>Bitfield operations<a class="headerlink" href="#bitfield-operations" title="Permalink to this heading">¶</a></h2>
<p>A set of macros are available to manipulate bitfields without manually constructing hex masks.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">f0</span>
<span class="nb">setbit(</span><span class="s">s0</span><span class="p">,</span> <span class="m">0</span><span class="nb">)</span>                <span class="c">; s0 = f1</span>
<span class="nb">setbit(</span><span class="s">s0</span><span class="p">,</span> <span class="m">2</span><span class="nb">)</span>                <span class="c">; s0 = f5</span>
<span class="nb">clearbit(</span><span class="s">s0</span><span class="p">,</span> <span class="m">7</span><span class="nb">)</span>              <span class="c">; s0 = 75</span>

<span class="nb">setmask(</span><span class="s">s0</span><span class="p">,</span> <span class="nb">mask(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="nb">))</span>   <span class="c">; s0 = 7f</span>
<span class="nb">clearmask(</span><span class="s">s0</span><span class="p">,</span> <span class="nb">mask(</span><span class="m">4</span><span class="p">,</span><span class="m">5</span><span class="p">,</span><span class="m">6</span><span class="p">,</span><span class="m">7</span><span class="nb">))</span> <span class="c">; s0 = 0f</span>

<span class="nb">testbit(</span><span class="s">s0</span><span class="p">,</span> <span class="m">0</span><span class="nb">)</span>               <span class="c">; Test if bit-0 is set or clear</span>
<span class="k">jump</span> <span class="n">nz</span><span class="p">,</span> <span class="n">somewhere</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="library.html#pb.maskh" title="maskh"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">maskh()</span></code></a> macro works like <a class="reference internal" href="library.html#pb.mask" title="mask"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">mask()</span></code></a> but produces a result in PicoBlaze hex format so it can be used as a direct argument to any instruction that takes a constant.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="nb">maskh(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">6</span><span class="p">,</span><span class="m">7</span><span class="nb">)</span>  <span class="c">; Expands to &quot;load s0, c7&quot;</span>
</pre></div>
</div>
</section>
<section id="shift-and-rotate">
<span id="shift-and-rotate-by-multiple-bits"></span><h2>Shift and rotate<a class="headerlink" href="#shift-and-rotate" title="Permalink to this heading">¶</a></h2>
<p>Shifts and rotates are inconvenient in PicoBlaze assembly because they must be performed one bit at a time. Macros are provided that generate shifts and rotates by any number of bits more easily. The shift amount must be a constant integer. It cannot come from another register.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">01</span>
<span class="nb">sl0(</span><span class="s">s0</span><span class="p">,</span> <span class="m">4</span><span class="nb">)</span>  <span class="c">; Shift left by 4 bits  s0 = 00010000&#39;b</span>
<span class="nb">sr1(</span><span class="s">s0</span><span class="p">,</span> <span class="m">3</span><span class="nb">)</span>  <span class="c">; Shift right by 3 bits with 1&#39;s inserted  s0 = 11100010&#39;b</span>
</pre></div>
</div>
<p>All 10 of the PicoBlaze shift and rotate instructions have macro equivalents. The original instructions can still be used as usual.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="library.html#pb.sl0" title="sl0"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">sl0()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.sl1" title="sl1"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">sl1()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.sla" title="sla"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">sla()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.slx" title="slx"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">slx()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.rl" title="rl"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">rl()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="library.html#pb.sr0" title="sr0"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">sr0()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.sr1" title="sr1"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">sr1()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.sra" title="sra"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">sra()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.srx" title="srx"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">srx()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.rr" title="rr"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">rr()</span></code></a></p></td>
</tr>
</tbody>
</table>
</section>
<section id="conditional-jump-call-and-return">
<span id="id2"></span><h2>Conditional jump call and return<a class="headerlink" href="#conditional-jump-call-and-return" title="Permalink to this heading">¶</a></h2>
<p>PicoBlaze assembly depends on using the carry and zero flags directly to handle conditional <a class="reference internal" href="language.html#inst-jump"><span class="std std-ref">jump</span></a> and <a class="reference internal" href="language.html#inst-call"><span class="std std-ref">call</span></a> instructions. It can be difficult to remember how the carry flag is interpreted so a set of macros are provided to perform more natural conditional instructions.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">compare</span> <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span>
<span class="nb">jne(</span><span class="s">not_equal</span><span class="nb">)</span>           <span class="c">; Jump if s0 != s1</span>
<span class="nb">jeq(</span><span class="s">equal</span><span class="nb">)</span>               <span class="c">; Jump if s0 == s1</span>
<span class="nb">jge(</span><span class="s">greater_or_equal</span><span class="nb">)</span>    <span class="c">; Jump if s0 &gt;= s1</span>
<span class="nb">jlt(</span><span class="s">less_than</span><span class="nb">)</span>           <span class="c">; Jump if s0 &lt; s1</span>

<span class="nb">callne(</span><span class="s">not_equal</span><span class="nb">)</span>        <span class="c">; Call if s0 != s1</span>
<span class="nb">calleq(</span><span class="s">equal</span><span class="nb">)</span>            <span class="c">; Call if s0 == s1</span>
<span class="nb">callge(</span><span class="s">greater_or_equal</span><span class="nb">)</span> <span class="c">; Call if s0 &gt;= s1</span>
<span class="nb">calllt(</span><span class="s">less_than</span><span class="nb">)</span>        <span class="c">; Call if s0 &lt; s1</span>

<span class="k">retne</span>                    <span class="c">; Return if s0 != s1</span>
<span class="k">reteq</span>                    <span class="c">; Return if s0 == s1</span>
<span class="k">retge</span>                    <span class="c">; Return if s0 &gt;= s1</span>
<span class="k">retlt</span>                    <span class="c">; Return if s0 &lt; s1</span>
</pre></div>
</div>
</section>
<section id="conditional-if-then-else">
<h2>Conditional if-then-else<a class="headerlink" href="#conditional-if-then-else" title="Permalink to this heading">¶</a></h2>
<p>A high level <a class="reference internal" href="library.html#pb.if" title="if"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">if()</span></code></a> macro is present that provides evaluation of infix Boolean expressions. It takes the form of <code class="docutils literal notranslate"><span class="pre">if(&lt;expr&gt;,&lt;true</span> <span class="pre">block&gt;,[&lt;expr&gt;,&lt;true</span> <span class="pre">block</span> <span class="pre">2&gt;...|&lt;else</span> <span class="pre">block&gt;])</span></code>. The expression syntax uses conventional C operators ==, !=, &lt;, ,&gt;=, &gt;, &lt;=, &amp;, and ~&amp;. Additional expressions after the first true block produce else-if evaluation similar to m4’s <code class="docutils literal notranslate"><span class="pre">ifelse()</span></code> macro. It is important to guard code blocks with m4 quotes to avoid errors caused by m4 splitting strings with internal commas. The <a class="reference internal" href="library.html#pb.if" title="if"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">if()</span></code></a> macro implements a <a class="reference internal" href="language.html#inst-compare"><span class="std std-ref">compare</span></a> instruction and generates the appropriate branch logic to test the flags. Unique generated labels are inserted into the code to manage the sequencing of the code blocks.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">05</span>
<span class="nb">if(</span><span class="s">s0</span> <span class="o">&lt;</span> <span class="m">10</span><span class="p">,</span>
  <span class="s">`load</span> <span class="s">s1</span><span class="p">,</span> <span class="s">&quot;T&quot;</span>
  <span class="s">output</span> <span class="s">s1</span><span class="p">,</span> <span class="m">00</span><span class="s">&#39;</span><span class="p">,</span>
<span class="s">;</span> <span class="s">else</span><span class="o">-</span><span class="s">if</span>
<span class="s">s0</span> <span class="o">&lt;</span> <span class="m">8</span><span class="p">,</span>
  <span class="s">`load</span> <span class="s">s1</span><span class="p">,</span> <span class="s">&quot;t&quot;</span>
  <span class="s">output</span> <span class="s">s1</span><span class="p">,</span> <span class="m">01</span><span class="s">&#39;</span><span class="p">,</span>
<span class="s">;else</span>
  <span class="s">`load</span> <span class="s">s1</span> <span class="s">&quot;F&quot;</span>
  <span class="s">output</span> <span class="s">s1</span><span class="p">,</span> <span class="m">02</span><span class="s">&#39;</span>
<span class="nb">)</span>
</pre></div>
</div>
<p>In addition, the &amp; and ~&amp; operators can be used to generate a <a class="reference internal" href="language.html#inst-test"><span class="std std-ref">test</span></a> instruction instead of <a class="reference internal" href="language.html#inst-compare"><span class="std std-ref">compare</span></a>. For &amp; the true block is executed if the test result is non-zero:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="c">; Check if MSB is set</span>
<span class="nb">if(</span><span class="s">s0</span> <span class="s">&amp;</span> <span class="mh">0x80</span><span class="p">,</span> <span class="s">`load</span> <span class="s">s1</span><span class="p">,</span> <span class="m">00</span><span class="s">&#39;</span><span class="nb">)</span>
</pre></div>
</div>
<p>For ~&amp; the true block is executed if the test result is zero:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="c">; Check if MSB is clear</span>
<span class="nb">if(</span><span class="s">s0</span> <span class="o">~</span><span class="s">&amp;</span> <span class="mh">0x80</span><span class="p">,</span> <span class="s">`load</span> <span class="s">s1</span><span class="p">,</span> <span class="m">00</span><span class="s">&#39;</span><span class="nb">)</span>
</pre></div>
</div>
<p>You can invoke signed comparison using the <a class="reference internal" href="library.html#pb.compares" title="compares"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">compares()</span></code></a> macro by wrapping the expression in <a class="reference internal" href="library.html#pb.signed" title="signed"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">signed()</span></code></a>:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">load</span> <span class="n">s0</span> <span class="nb">evalh(</span><span class="o">-</span><span class="m">10</span><span class="nb">)</span> <span class="c">; -10 = 0xF6 which evaluates as &gt; 5 in unsigned comparison</span>
<span class="nb">if(signed(</span><span class="s">s0</span> <span class="o">&lt;</span> <span class="m">5</span><span class="nb">)</span><span class="p">,</span><span class="s">`load</span> <span class="s">s1</span><span class="p">,</span> <span class="m">00</span><span class="s">&#39;</span><span class="nb">)</span> <span class="c">; evaluate as &lt; 5 using signed comparison</span>
</pre></div>
</div>
<p>Macros can be used within the code blocks including nested <a class="reference internal" href="library.html#pb.if" title="if"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">if()</span></code></a> macros:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">if(</span><span class="s">s0</span> <span class="o">&lt;</span> <span class="s">s1</span><span class="p">,</span>
   <span class="s">`&lt;something&gt;&#39;</span><span class="p">,</span>
<span class="s">;</span> <span class="s">else</span>
  <span class="s">`if(s2</span> <span class="o">&gt;</span><span class="s">=</span> <span class="s">s3</span><span class="p">,</span><span class="s">`&lt;something</span> <span class="s">else</span><span class="o">&gt;</span><span class="s">&#39;</span><span class="nb">)</span>&#39;
)
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> operators have to be simulated because the limited Picoblaze ALU flags don’t permit them to be implemented directly. If both operands are registers they are swapped and the reverse comparison operation (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code> or <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> ) is performed. If the right operand is a constant it has to be adjusted by adding one to its value and swapping the true and false conditional blocks. For instance “s0 &gt; 0x20” is converted to “s0 &lt;= 0x21” with the false condition (originally true) executed when s0 is greater than 0x20.</p>
<p>This can lead to problems when doing comparisons with 0xFF because the 0x100 can’t be used as an immediate instruction value. You may have to find alternate ways to express comparison logic when dealing with the 0xFF and 0x00 boundary values. Consider a loop counter that you want to terminate after passing 0xFF. Instead of testing for “sN &gt; 0xFF” you should test for “sN != 0” and ensure that this won’t cause early termination at the start of the loop.</p>
</div>
<section id="c-style-syntax">
<span id="c-style-if-then"></span><h3>C-style syntax<a class="headerlink" href="#c-style-syntax" title="Permalink to this heading">¶</a></h3>
<p>The m4 syntax for the <a class="reference internal" href="library.html#pb.if" title="if"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">if()</span></code></a> macro is a little untidy but an alternate C-style syntax can be used. It is implemented using an initial preprocessing step where pattern matching converts C-style control flow statements into m4 syntax. Instead of m4 quotes, code blocks are surrounded by mandatory curly braces. Unlike m4 macros, whitespace is permitted between the <code class="docutils literal notranslate"><span class="pre">if</span></code> keyword and its comparison expression.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">if (</span><span class="s">s0</span> <span class="o">&lt;</span> <span class="s">s1</span><span class="nb">)</span> <span class="p">{</span>
  <span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="sc">&quot;T&quot;</span>
<span class="p">}</span> <span class="nb">else</span> <span class="nb">if (</span><span class="s">s2</span> <span class="o">==</span> <span class="s">s3</span><span class="nb">)</span> <span class="p">{</span>
  <span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="sc">&quot;t&quot;</span>
<span class="p">}</span> <span class="nb">else</span> <span class="p">{</span>
  <span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="sc">&quot;F&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A set of lower level if-then-else macros are provided to expose the internal workings of <a class="reference internal" href="library.html#pb.if" title="if"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">if()</span></code></a>. The macros are <a class="reference internal" href="library.html#pb.ifeq" title="ifeq"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">ifeq()</span></code></a>, <a class="reference internal" href="library.html#pb.ifne" title="ifne"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">ifne()</span></code></a>, <a class="reference internal" href="library.html#pb.ifge" title="ifge"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">ifge()</span></code></a>, and <a class="reference internal" href="library.html#pb.iflt" title="iflt"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">iflt()</span></code></a>. Unlike <a class="reference internal" href="library.html#pb.if" title="if"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">if()</span></code></a>, no <a class="reference internal" href="language.html#inst-compare"><span class="std std-ref">compare</span></a> or <a class="reference internal" href="language.html#inst-test"><span class="std std-ref">test</span></a> instruction is generated from an expression. You have to prepare the flags on your own. The first argument is the code to execute for the true condition. An optional second argument is used for the else clause.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">compare</span> <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span>
<span class="nb">ifeq(</span>
  <span class="s">`load</span> <span class="s">s4</span><span class="p">,</span> <span class="m">20</span>
   <span class="s">output</span> <span class="s">s4</span><span class="p">,</span> <span class="s">PORT&#39;</span><span class="p">,</span>
<span class="s">;</span> <span class="s">else</span>
  <span class="s">`load</span> <span class="s">s4</span><span class="p">,</span> <span class="m">30</span>
   <span class="s">output</span> <span class="s">s4</span><span class="p">,</span> <span class="s">PORT2&#39;</span><span class="nb">)</span>
</pre></div>
</div>
<p>This expands to the following:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">compare</span> <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span>
<span class="k">jump</span> <span class="n">nz</span><span class="p">,</span> <span class="n">NEQ_f1_0001</span>
<span class="k">load</span> <span class="n">s4</span><span class="p">,</span> <span class="mh">20</span>
   <span class="k">output</span> <span class="n">s4</span><span class="p">,</span> <span class="n">PORT</span>
<span class="k">jump</span> <span class="n">ENDIF_f1_0002</span>
<span class="nl">NEQ_f1_0001:</span>
<span class="c">; else</span>
  <span class="k">load</span> <span class="n">s4</span><span class="p">,</span> <span class="mh">30</span>
   <span class="k">output</span> <span class="n">s4</span><span class="p">,</span> <span class="n">PORT2</span>
<span class="nl">ENDIF_f1_0002:</span>
</pre></div>
</div>
</section>
</section>
<section id="looping">
<h2>Looping<a class="headerlink" href="#looping" title="Permalink to this heading">¶</a></h2>
<p>Similarly to <a class="reference internal" href="library.html#pb.if" title="if"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">if()</span></code></a> there are a set of high level looping macros <a class="reference internal" href="library.html#pb.for" title="for"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">for()</span></code></a>, <a class="reference internal" href="library.html#pb.while" title="while"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">while()</span></code></a>, and <a class="reference internal" href="library.html#pb.dowhile" title="dowhile"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">dowhile()</span></code></a>. They implement the corresponding looping constructs using the syntax <code class="docutils literal notranslate"><span class="pre">for(&lt;init&gt;,&lt;expr&gt;,&lt;update&gt;,&lt;loop</span> <span class="pre">body&gt;)</span></code> and <code class="docutils literal notranslate"><span class="pre">[do]while(&lt;expr&gt;,&lt;loop</span> <span class="pre">body&gt;)</span></code>. Signed comparison is supported just as with <a class="reference internal" href="library.html#pb.if" title="if"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">if()</span></code></a> using the <a class="reference internal" href="library.html#pb.signed" title="signed"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">signed()</span></code></a> macro as a modifier. The for loop macro uses the <a class="reference internal" href="library.html#pb.expr" title="expr"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">expr()</span></code></a> <a class="reference internal" href="#expression-parser"><span class="std std-ref">macro syntax</span></a> for the <em>init</em> and <em>update</em> fields.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">for(</span><span class="s">s0</span> <span class="o">:=</span> <span class="o">-</span><span class="m">10</span><span class="p">,</span> <span class="nb">signed(</span><span class="s">s0</span> <span class="o">&lt;</span> <span class="m">10</span><span class="nb">)</span><span class="p">,</span> <span class="s">s0</span> <span class="o">:=</span> <span class="s">s0</span> <span class="o">+</span> <span class="m">1</span><span class="p">,</span>
  <span class="s">`output</span> <span class="s">s1</span><span class="p">,</span> <span class="s">P_FOO&#39;</span>
<span class="nb">)</span>
</pre></div>
</div>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="c">; Output s1 to port 00 10 times</span>
<span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">00</span>
<span class="nb">while(</span><span class="s">s0</span> <span class="o">&lt;</span> <span class="m">10</span><span class="p">,</span>
  <span class="s">`output</span> <span class="s">s1</span><span class="p">,</span> <span class="s">P_FOO</span>
   <span class="s">add</span> <span class="s">s0</span><span class="p">,</span> <span class="m">01</span><span class="s">&#39;</span>
<span class="nb">)</span>
</pre></div>
</div>
<section id="c-style-looping">
<span id="id3"></span><h3>C-style syntax<a class="headerlink" href="#c-style-looping" title="Permalink to this heading">¶</a></h3>
<p>An alternate C-style syntax is also available for <a class="reference internal" href="library.html#pb.for" title="for"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">for()</span></code></a>, <a class="reference internal" href="library.html#pb.while" title="while"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">while()</span></code></a>, and <a class="reference internal" href="library.html#pb.dowhile" title="dowhile"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">dowhile()</span></code></a>. Note that the <a class="reference internal" href="library.html#pb.for" title="for"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">for()</span></code></a> macro continues to use commas to separate the sections.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="c">; For loops</span>
<span class="nb">for (</span><span class="s">s0</span> <span class="o">:=</span> <span class="m">0</span><span class="p">,</span> <span class="s">s0</span> <span class="o">&lt;</span> <span class="s">s1</span><span class="p">,</span> <span class="s">s0</span> <span class="o">:=</span> <span class="s">s0</span> <span class="o">+</span> <span class="m">1</span><span class="nb">)</span> <span class="p">{</span>
  <span class="k">output</span> <span class="n">s0</span><span class="p">,</span> <span class="n">P_FOO</span>
<span class="p">}</span>

<span class="c">; While loops</span>
<span class="nb">while (</span><span class="s">s0</span> <span class="o">&lt;</span> <span class="s">s1</span><span class="nb">)</span> <span class="p">{</span>
  <span class="k">add</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">01</span>
  <span class="k">output</span> <span class="n">s0</span><span class="p">,</span> <span class="n">P_FOO</span>
<span class="p">}</span>

<span class="c">; Do-while loops</span>
<span class="k">do</span> {
  <span class="k">add</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">01</span>
  <span class="k">output</span> <span class="n">s0</span><span class="p">,</span> <span class="n">P_FOO</span>
<span class="p">}</span> <span class="nb">while (</span><span class="s">s0</span> <span class="o">&lt;</span> <span class="s">s1</span><span class="nb">)</span>
</pre></div>
</div>
<p>Two macros, <a class="reference internal" href="library.html#pb.break" title="break"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">break()</span></code></a> and <a class="reference internal" href="library.html#pb.continue" title="continue"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">continue()</span></code></a>, are available to exit the current loop and restart a loop respectively. In a for loop the <a class="reference internal" href="library.html#pb.continue" title="continue"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">continue()</span></code></a> macro will execute the <em>update</em> field expression to prepare the next iteration.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="c">; &quot;continue&quot; resumes execution here</span>
<span class="nb">while (</span><span class="s">s0</span> <span class="o">&lt;</span> <span class="s">s1</span><span class="nb">)</span> <span class="p">{</span>
  <span class="k">add</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">01</span>
  <span class="nb">if (</span><span class="s">s3</span> <span class="o">==</span> <span class="m">4</span><span class="nb">)</span> <span class="p">{</span> <span class="k">continue</span> }
  <span class="nb">if (</span><span class="s">s2</span> <span class="o">==</span> <span class="m">5</span><span class="nb">)</span> <span class="p">{</span> <span class="k">break</span> }
  <span class="k">output</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">00</span>
<span class="p">}</span>
<span class="c">; &quot;break&quot; resumes execution here</span>
</pre></div>
</div>
</section>
</section>
<section id="procedures-and-functions">
<h2>Procedures and Functions<a class="headerlink" href="#procedures-and-functions" title="Permalink to this heading">¶</a></h2>
<p>A set of macros are available that can streamline the creation of procedures, functions, and interrupt service routines. All of these macros have a C-style block syntax which is the preferred way to invoke them.</p>
<section id="proc">
<h3>proc<a class="headerlink" href="#proc" title="Permalink to this heading">¶</a></h3>
<p>The most basic is the <a class="reference internal" href="library.html#pb.proc" title="proc"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">proc()</span></code></a> macro which is a convenience routine creating a labeled code block with an included <a class="reference internal" href="library.html#pb.vars" title="vars"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">vars()</span></code></a> macro for variable definitions, a final <a class="reference internal" href="language.html#inst-return"><span class="std std-ref">return</span></a> instruction, and automatic “;PRAGMA” comments identifying it as a function.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">proc</span> <span class="nb">addinc(</span><span class="s">s0</span> <span class="s">is</span> <span class="s">count</span><span class="p">,</span> <span class="s">s1</span> <span class="s">is</span> <span class="s">inc</span><span class="nb">)</span> {
  <span class="k">add</span> <span class="n">count</span><span class="p">,</span> <span class="n">inc</span>
<span class="p">}</span>
...

<span class="k">call</span> <span class="n">addinc</span>

<span class="c">; Expands to:</span>

        <span class="cs">;PRAGMA function addinc [s0 is count, s1 is inc] begin</span>
<span class="nl">addinc:</span>
        <span class="k">ADD</span> <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span>
        <span class="k">RETURN</span>
        <span class="cs">;PRAGMA function addinc end</span>

<span class="k">CALL</span> <span class="n">addinc</span>
</pre></div>
</div>
<p>The “argument” list to proc is passed on to the <a class="reference internal" href="library.html#pb.vars" title="vars"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">vars()</span></code></a> macro. It can include local variables used by the procedure. You are responsible for loading arguments into registers and cleaning up temporary registers.</p>
</section>
<section id="func">
<h3>func<a class="headerlink" href="#func" title="Permalink to this heading">¶</a></h3>
<p>The <a class="reference internal" href="library.html#pb.func" title="func"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">func()</span></code></a> macro provides a more elaborate function generator that takes care of handling arguments by passing them on the stack. A dynamically generated macro is created for calling each defined function. <a class="reference internal" href="library.html#pb.func" title="func"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">func()</span></code></a> takes a list of registers to pass as arguments as well as an optional number of bytes for values returned on the stack. those registers are placed on the stack and then popped into local registers that are saved and restored after the function completes. The argument list is in the same “Sn is Y” syntax used by the <a class="reference internal" href="library.html#pb.vars" title="vars"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">vars()</span></code></a> macro but you can also just list register names without providing an alias.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="c">; func &lt;funcname&gt;(&lt;vars&gt;) : &lt;optional return bytes&gt; {}</span>

<span class="k">func</span> <span class="nb">addinc(</span><span class="s">s0</span> <span class="s">is</span> <span class="s">count</span><span class="p">,</span> <span class="s">s1</span> <span class="s">is</span> <span class="s">inc</span><span class="nb">)</span>: 1 {
  <span class="k">add</span> <span class="n">count</span><span class="p">,</span> <span class="n">inc</span>
  <span class="nb">retvalue(</span><span class="s">count</span><span class="p">,</span> <span class="m">1</span><span class="nb">)</span> <span class="c">; Save the return value on the stack</span>
<span class="p">}</span>
...

<span class="c">; Call function with s3 and s4 as args</span>
<span class="nb">addinc(</span><span class="s">s3</span><span class="p">,</span> <span class="s">s4</span><span class="nb">)</span>
<span class="nb">pop(</span><span class="s">s5</span><span class="nb">)</span>       <span class="c">; Get the return value</span>

<span class="c">; Expands to:</span>
              <span class="cs">;PRAGMA function addinc [stack(s0 is count, s1 is inc : 1)] begin</span>
      <span class="nl">addinc:</span>
              <span class="ge">&lt;Save registers and retrieve arguments from stack frame&gt;</span>

              <span class="k">ADD</span> <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span>
              <span class="ge">&lt;Put the result on the stack&gt;</span>

<span class="nl">LEAVE_addinc:</span>
              <span class="ge">&lt;Restore saved registers and remove stack frame&gt;</span>
              <span class="k">RETURN</span>
              <span class="cs">;PRAGMA function addinc end</span>

              <span class="c">; Call function with s3 and s4 as args</span>
              <span class="c">; Push arguments:</span>
              <span class="k">STORE</span> <span class="n">s3</span><span class="p">,</span> <span class="p">(</span><span class="n">sf</span><span class="p">)</span>                 <span class="c">; Push</span>
              <span class="k">SUB</span> <span class="n">sf</span><span class="p">,</span> <span class="mh">01</span>
              <span class="k">STORE</span> <span class="n">s4</span><span class="p">,</span> <span class="p">(</span><span class="n">sf</span><span class="p">)</span>                 <span class="c">; Push</span>
              <span class="k">SUB</span> <span class="n">sf</span><span class="p">,</span> <span class="mh">01</span>
              <span class="k">CALL</span> <span class="n">addinc</span>
              <span class="k">ADD</span> <span class="n">sf</span><span class="p">,</span> <span class="mh">01</span>
              <span class="k">FETCH</span> <span class="n">s5</span><span class="p">,</span> <span class="p">(</span><span class="n">sf</span><span class="p">)</span>                 <span class="c">; Pop</span>
</pre></div>
</div>
<p>After the function call the registers will be in the same state they were before the function call and any return values will be on the stack. Unlike with <a class="reference internal" href="library.html#pb.proc" title="proc"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">proc()</span></code></a> the parameter list is only used to define arguments. You are responsible for preserving any registers used internally for local variables. The <a class="reference internal" href="library.html#pb.retvalue" title="retvalue"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">retvalue()</span></code></a> macro takes a register for its first argument and the index of the return byte from the top of the stack starting from 1.</p>
<p>You cannot use a <a class="reference internal" href="language.html#inst-return"><span class="std std-ref">return</span></a> instruction inside the code body of a <a class="reference internal" href="library.html#pb.func" title="func"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">func()</span></code></a> macro because the stack cleanup code will not be executed. Instead you must call the <a class="reference internal" href="library.html#pb.leave_func" title="leave_func"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">leave_func()</span></code></a> macro whenever you want to exit early. It will ensure the cleanup code is executed.</p>
</section>
<section id="isr">
<h3>isr<a class="headerlink" href="#isr" title="Permalink to this heading">¶</a></h3>
<p>A variant of the <a class="reference internal" href="library.html#pb.func" title="func"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">func()</span></code></a> macro is available for defining ISRs. The <a class="reference internal" href="library.html#pb.isr" title="isr"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">isr()</span></code></a> macro is similar to <a class="reference internal" href="library.html#pb.func" title="func"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">func()</span></code></a> but you specify an address for the interrupt vector instead of a name and in place of the return byte count you specify whether the ISR returns with interrupts enabled or disabled. Interrupts are enabled by default if the last parameter is omitted.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="c">; isr &lt;address&gt;(&lt;vars&gt;) : [enable | disable] {}</span>

<span class="k">isr</span> <span class="nb">0x3FF(</span><span class="s">s0</span><span class="nb">)</span> : enable {
  <span class="k">output</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">FF</span>
<span class="p">}</span>

<span class="c">; Expands to:</span>

       <span class="nl">__ISR:</span>
              <span class="k">ADDRESS</span> <span class="mh">3ff</span>                    <span class="c">; 0x3FF</span>
              <span class="k">JUMP</span> <span class="n">__ISR</span>
              <span class="k">ADDRESS</span> <span class="n">__ISR</span>
              <span class="cs">;PRAGMA function __ISR begin</span>
              <span class="ge">&lt;Save registers on stack&gt;</span>
              <span class="k">OUTPUT</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">FF</span>

 <span class="nl">LEAVE___ISR:</span>
              <span class="ge">&lt;Restore registers from stack&gt;</span>

              <span class="k">RETURNI</span> <span class="n">enable</span>
              <span class="cs">;PRAGMA function __ISR end</span>
</pre></div>
</div>
<p>ISRs take no arguments and the variable list only serves to identify which registers are used in the ISR so that they can be saved on the stack. There can only be one <a class="reference internal" href="library.html#pb.isr" title="isr"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">isr()</span></code></a> macro call in a program. You can use <a class="reference internal" href="library.html#pb.leave_func" title="leave_func"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">leave_func()</span></code></a> or the equivalent <a class="reference internal" href="library.html#pb.leave_isr" title="leave_isr"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">leave_isr()</span></code></a> macro to exit early from an ISR. Do not call <a class="reference internal" href="language.html#inst-returni"><span class="std std-ref">returni</span></a> directly within the ISR code block as that will leave saved registers on the stack without cleaning up.</p>
</section>
</section>
<section id="delay-generators">
<h2>Delay generators<a class="headerlink" href="#delay-generators" title="Permalink to this heading">¶</a></h2>
<p>A set of delay generator macros are available to implement software delays. The simplest is <a class="reference internal" href="library.html#pb.delay_cycles" title="delay_cycles"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">delay_cycles()</span></code></a> which delays by a number of instruction cycles (each being two clock cycles). By default it is implemented with recursive loops and requires no registers to function.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">delay_cycles(</span><span class="m">40</span><span class="nb">)</span>   <span class="c">; Delay for 40 instructions (80 clock periods)</span>
</pre></div>
</div>
<p>This expands to the following recursive code implemented in 13 instructions:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span>                   <span class="k">CALL</span> <span class="n">DTREE_f1_0001_4</span>           <span class="c">; Delay for 33 cycles</span>
                   <span class="k">JUMP</span> <span class="n">DTREE_f1_0001_end</span>
  <span class="nl">DTREE_f1_0001_4:</span> <span class="k">CALL</span> <span class="n">DTREE_f1_0001_3</span>
  <span class="nl">DTREE_f1_0001_3:</span> <span class="k">CALL</span> <span class="n">DTREE_f1_0001_2</span>
  <span class="nl">DTREE_f1_0001_2:</span> <span class="k">CALL</span> <span class="n">DTREE_f1_0001_1</span>
  <span class="nl">DTREE_f1_0001_1:</span> <span class="k">CALL</span> <span class="n">DTREE_f1_0001_0</span>
  <span class="nl">DTREE_f1_0001_0:</span> <span class="k">RETURN</span>
<span class="nl">DTREE_f1_0001_end:</span>
                   <span class="k">CALL</span> <span class="n">DTREE_f1_0002_1</span>           <span class="c">; Delay for 5 cycles</span>
                   <span class="k">JUMP</span> <span class="n">DTREE_f1_0002_end</span>
  <span class="nl">DTREE_f1_0002_1:</span> <span class="k">CALL</span> <span class="n">DTREE_f1_0002_0</span>
  <span class="nl">DTREE_f1_0002_0:</span> <span class="k">RETURN</span>
<span class="nl">DTREE_f1_0002_end:</span>
                   <span class="k">LOAD</span> <span class="n">sf</span><span class="p">,</span> <span class="n">sf</span>                    <span class="c">; NOP</span>
                   <span class="k">LOAD</span> <span class="n">sf</span><span class="p">,</span> <span class="n">sf</span>                    <span class="c">; NOP</span>
</pre></div>
</div>
<p>The delay can be from 0 to approximately 100e9 but a practical limit would be to keep the delay less than 200 cycles to restrict the amount of generated code. You must ensure that there is enough space on the call stack to perform the recursive calls. In the example above the 33-cycle delay block extends five calls deep.</p>
<p>An alternate implementation of <a class="reference internal" href="library.html#pb.delay_cycles" title="delay_cycles"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">delay_cycles()</span></code></a> can be invoked by first configuring it with the <a class="reference internal" href="library.html#pb.use_delay_reg" title="use_delay_reg"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_delay_reg()</span></code></a> macro. You call it with a single register to use for a delay counter. This register must be different than the ones used for the long period delay macros described next. With a delay register configured, the <a class="reference internal" href="library.html#pb.delay_cycles" title="delay_cycles"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">delay_cycles()</span></code></a> macro will be implemented as a small loop for delays of 511 cycles or less. Longer delays will fall back to using recursive delay trees.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">use_delay_reg(</span><span class="s">s6</span><span class="nb">)</span>
<span class="nb">delay_cycles(</span><span class="m">40</span><span class="nb">)</span>

<span class="c">; Expands to:</span>


                <span class="k">LOAD</span> <span class="n">s6</span><span class="p">,</span> <span class="mh">13</span>                    <span class="c">; (40 - 1) / 2</span>
 <span class="nl">DLOOP_f1_0001:</span>
                <span class="k">SUB</span> <span class="n">s6</span><span class="p">,</span> <span class="mh">01</span>
                <span class="k">JUMP</span> <span class="n">nz</span><span class="p">,</span> <span class="n">DLOOP_f1_0001</span>
                <span class="k">LOAD</span> <span class="n">se</span><span class="p">,</span> <span class="n">se</span>                    <span class="c">; NOP</span>
</pre></div>
</div>
<section id="time-delays">
<h3>Time delays<a class="headerlink" href="#time-delays" title="Permalink to this heading">¶</a></h3>
<p>Delays by microseconds and milliseconds are implemented with the <a class="reference internal" href="library.html#pb.delay_us" title="delay_us"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">delay_us()</span></code></a> and <a class="reference internal" href="library.html#pb.delay_ms" title="delay_ms"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">delay_ms()</span></code></a> macros. Before using these you must establish the system clock frequency with the <a class="reference internal" href="library.html#pb.use_clock" title="use_clock"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_clock()</span></code></a> macro. These delays are cycle accurate if the requested delay is an integer multiple of the clock period. They have the ability to adjust the delay down by a certain number of instructions if needed to account for function call or loop overhead.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">use_clock(</span><span class="m">100</span><span class="nb">)</span>                     <span class="c">; 100 MHz system clock</span>
<span class="nb">use_delay_reg(</span><span class="s">s6</span><span class="nb">)</span>                  <span class="c">; Use compact internal delay loop</span>

<span class="c">; 10 ms delay subroutine</span>
<span class="nl">delay_10ms:</span> <span class="nb">delay_ms(</span><span class="m">10</span><span class="p">,</span> <span class="s">s4</span><span class="p">,</span><span class="s">s5</span><span class="p">,</span> <span class="m">2</span><span class="nb">)</span> <span class="c">; Adjust delay by 2 instructions for call and return</span>
            <span class="k">return</span>

...
<span class="k">call</span> <span class="n">delay_10ms</span>
<span class="c">; Exactly 10 ms have passed here</span>

...
<span class="nb">delay_ms(</span><span class="m">10</span><span class="p">,</span> <span class="s">s4</span><span class="p">,</span> <span class="s">s5</span><span class="nb">)</span>               <span class="c">; Inline delay by 10 ms</span>
<span class="c">; Exactly 10 ms have passed here</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">delay_*()</span></code> macros take a delay value, a pair of registers and an optional instruction adjustment as arguments. The delay value is the amount of delay in the associated units. The upper delay limit depends on the clock frequency. It has a complex relationship that is approximated by the equation <code class="docutils literal notranslate"><span class="pre">max_delay</span> <span class="pre">=</span> <span class="pre">22.05e6</span> <span class="pre">*</span> <span class="pre">clock_freq</span> <span class="pre">^</span> <span class="pre">-1.0016</span></code> . You will get a macro error if a delay is too large for the currently selected frequency. The following table shows the maximum delays for representative clock frequencies:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>50 MHz</p></td>
<td><p>429 ms</p></td>
</tr>
<tr class="row-even"><td><p>75 MHz</p></td>
<td><p>286 ms</p></td>
</tr>
<tr class="row-odd"><td><p>100 MHz</p></td>
<td><p>214 ms</p></td>
</tr>
<tr class="row-even"><td><p>125 MHz</p></td>
<td><p>171 ms</p></td>
</tr>
<tr class="row-odd"><td><p>150 MHz</p></td>
<td><p>143 ms</p></td>
</tr>
</tbody>
</table>
<p>The registers are used for an internal 16-bit counter. The internal delay loop is automatically adjusted to ensure the count value fits within 16-bits. When implementing a delay as a subroutine, an adjustment can be added to account for the <a class="reference internal" href="language.html#inst-call"><span class="std std-ref">call</span></a> and <a class="reference internal" href="language.html#inst-return"><span class="std std-ref">return</span></a> instructions.</p>
</section>
<section id="variable-delays">
<h3>Variable delays<a class="headerlink" href="#variable-delays" title="Permalink to this heading">¶</a></h3>
<p>If you need to use multiple delays it may be desirable to have a common delay routine that supports variable delay counts. This is provided by the <a class="reference internal" href="library.html#pb.var_delay_us" title="var_delay_us"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">var_delay_us()</span></code></a> and <a class="reference internal" href="library.html#pb.var_delay_ms" title="var_delay_ms"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">var_delay_ms()</span></code></a> macros. They are similar to the fixed delays but are not cycle accurate and have no provision for adjustment.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">use_clock(</span><span class="m">50</span><span class="nb">)</span>            <span class="c">; 50 MHz system clock</span>

<span class="nb">define(</span><span class="s">MAX_DELAY</span><span class="p">,</span> <span class="m">200</span><span class="nb">)</span>   <span class="c">; Maximum 200 us delay</span>

<span class="nl">var_delay:</span> <span class="nb">var_delay_us(</span><span class="s">MAX_DELAY</span><span class="p">,</span> <span class="s">s4</span><span class="p">,</span><span class="s">s5</span><span class="nb">)</span>
           <span class="k">return</span>
...

<span class="nb">load16(</span><span class="s">s4</span><span class="p">,</span><span class="s">s5</span><span class="p">,</span> <span class="nb">var_count_us(</span><span class="m">20</span><span class="p">,</span> <span class="s">MAX_DELAY</span><span class="nb">))</span>  <span class="c">; 20 us delay</span>
<span class="k">call</span> <span class="n">var_delay</span>
...

<span class="nb">load16(</span><span class="s">s4</span><span class="p">,</span><span class="s">s5</span><span class="p">,</span> <span class="nb">var_count_us(</span><span class="m">150</span><span class="p">,</span> <span class="s">MAX_DELAY</span><span class="nb">))</span> <span class="c">; 150 us delay</span>
<span class="k">call</span> <span class="n">var_delay</span>
</pre></div>
</div>
<p>The first argument to the <code class="docutils literal notranslate"><span class="pre">var_delay_*()</span></code> macros is the maximum delay value to support. When a delay is needed you must load the count registers with a constant computed with the <code class="docutils literal notranslate"><span class="pre">var_count_*()</span></code> macros.</p>
</section>
</section>
<section id="string-and-table-operations">
<span id="string-and-table-ops"></span><span id="id4"></span><h2>String and table operations<a class="headerlink" href="#string-and-table-operations" title="Permalink to this heading">¶</a></h2>
<p>PicoBlaze-3 doesn’t have the ability to handle strings as efficiently as PB6 because it lacks the <a class="reference internal" href="language.html#inst-load-return"><span class="std std-ref">load&amp;return</span></a> instruction but it is still necessary to work with them at times. Suppose that you have a subroutine “write_char” that writes characters in s0 out to a peripheral. You can write entire strings with the following:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">callstring(</span><span class="s">write_char</span><span class="p">,</span> <span class="s">s0</span><span class="p">,</span> <span class="s">`My</span> <span class="s">string&#39;</span><span class="nb">)</span> <span class="c">; Note use of m4 quotes `&#39; to enclose the string</span>
</pre></div>
</div>
<p>This expands to the following:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="sc">&quot;M&quot;</span>
<span class="k">call</span> <span class="n">write_char</span>
<span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="sc">&quot;y&quot;</span>
<span class="k">call</span> <span class="n">write_char</span>
<span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="sc">&quot; &quot;</span>
<span class="k">call</span> <span class="n">write_char</span>
...
<span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="sc">&quot;n&quot;</span>
<span class="k">call</span> <span class="n">write_char</span>
<span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="sc">&quot;g&quot;</span>
<span class="k">call</span> <span class="n">write_char</span>
</pre></div>
</div>
<p>Similarly you can call with arbitrary bytes in a table. The <a class="reference internal" href="library.html#pb.pbhex" title="pbhex"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">pbhex()</span></code></a> macro is useful here to express hex numbers with less clutter.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">calltable(</span><span class="s">write_char</span><span class="p">,</span> <span class="s">s0</span><span class="p">,</span>  <span class="nb">pbhex(</span><span class="mh">DE</span><span class="p">,</span> <span class="mh">AD</span><span class="p">,</span> <span class="mh">BE</span><span class="p">,</span> <span class="mh">EF</span><span class="nb">))</span>
</pre></div>
</div>
<p>There are four targets for string and table macros: “call”, “output”, “store”, and “inst”. They work similarly to the “call” macros above but generate <a class="reference internal" href="language.html#inst-output"><span class="std std-ref">output</span></a>, <a class="reference internal" href="language.html#inst-store"><span class="std std-ref">store</span></a>, or <a class="reference internal" href="language.html#inst-inst"><span class="std std-ref">inst</span></a> instructions in place of <a class="reference internal" href="language.html#inst-call"><span class="std std-ref">call</span></a>.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>callstring</p></td>
<td><p>outputstring</p></td>
<td><p>storestring</p></td>
<td><p>storestringat</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>calltable</p></td>
<td><p>outputtable</p></td>
<td><p>storetable</p></td>
<td><p>storetableat</p></td>
<td><p>insttable_le, insttable_be</p></td>
</tr>
</tbody>
</table>
<p>The <a class="reference internal" href="library.html#pb.storestringat" title="storestringat"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">storestringat()</span></code></a> and <a class="reference internal" href="library.html#pb.storetableat" title="storetableat"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">storetableat()</span></code></a> macros take a register as a pointer to the destination scratchpad address. The pointer register is incremented after storing each byte except for the last.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">constant</span> <span class="n">M_DATA</span><span class="p">,</span> <span class="mh">10</span>
<span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="n">M_DATA</span>
<span class="nb">storestringat(</span><span class="s">s0</span><span class="p">,</span> <span class="s">sF</span><span class="p">,</span> <span class="s">`Store</span> <span class="s">this&#39;</span><span class="nb">)</span> <span class="c">; sF is used as a temp register</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="library.html#pb.insttable_le" title="insttable_le"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">insttable_le()</span></code></a> and <a class="reference internal" href="library.html#pb.insttable_be" title="insttable_be"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">insttable_be()</span></code></a> macros generate packed <a class="reference internal" href="language.html#inst-inst"><span class="std std-ref">inst</span></a> directives for use as static data. The former generates little-endian instructions while the latter is big-endian.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">insttable_le(pbhex(</span><span class="mh">0a</span><span class="p">,</span> <span class="mh">0b</span><span class="p">,</span> <span class="mh">0c</span><span class="nb">))</span>
<span class="c">; Expands to:  inst 00b0a</span>
<span class="c">;              inst 0000c</span>

<span class="nb">insttable_be(pbhex(</span><span class="mh">0a</span><span class="p">,</span> <span class="mh">0b</span><span class="p">,</span> <span class="mh">0c</span><span class="nb">))</span>
<span class="c">; Expands to:  inst 00a0b</span>
<span class="c">;              inst 00c00</span>
</pre></div>
</div>
<p>The insttable macros only accept a list of decimal values directly but the <a class="reference internal" href="library.html#pb.asciiord" title="asciiord"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">asciiord()</span></code></a> macro can be used to convert strings to numeric data.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">insttable_le(asciiord(</span><span class="s">`Pack</span> <span class="s">strings</span> <span class="s">into</span> <span class="s">ROM&#39;</span><span class="nb">))</span>
<span class="c">; Expands to:</span>
  <span class="k">inst</span> <span class="mh">06150</span>
  <span class="k">inst</span> <span class="mh">06b63</span>
  <span class="k">inst</span> <span class="mh">07320</span>
  ...
  <span class="k">inst</span> <span class="mh">0206f</span>
  <span class="k">inst</span> <span class="mh">04f52</span>
  <span class="k">inst</span> <span class="mh">0004d</span>
</pre></div>
</div>
<p>This permits the compact storage of data bytes in the PicoBlaze ROM. If synthesized as a dual-ported block RAM, the data can be retrieved with external logic. The <code class="docutils literal notranslate"><span class="pre">picoblaze_dp_rom</span></code> component included with <a class="reference external" href="https://github.com/kevinpt/opbasm/blob/master/templates/picoblaze_rom.vhdl">picoblaze_rom.vhdl</a> provides a second read/write port for this purpose.</p>
<section id="escaped-strings">
<h3>Escaped strings<a class="headerlink" href="#escaped-strings" title="Permalink to this heading">¶</a></h3>
<p>The native PicoBlaze syntax does not permit the use of character escapes in strings. The macros <a class="reference internal" href="library.html#pb.estr" title="estr"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">estr()</span></code></a> and <a class="reference internal" href="library.html#pb.cstr" title="cstr"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">cstr()</span></code></a> provide a means for generating escaped strings without and with a NUL terminator respectively. They generate a list of integers representing each character in the string. The following C-style backslash escape codes are supported:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Escape</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>\\</cite></p></td>
<td><p>Literal “\”</p></td>
</tr>
<tr class="row-odd"><td><p>\n</p></td>
<td><p>Newline \ Line Feed</p></td>
</tr>
<tr class="row-even"><td><p>\r</p></td>
<td><p>Carriage Return</p></td>
</tr>
<tr class="row-odd"><td><p>\b</p></td>
<td><p>Backspace</p></td>
</tr>
<tr class="row-even"><td><p>\a</p></td>
<td><p>Bell</p></td>
</tr>
<tr class="row-odd"><td><p>\e</p></td>
<td><p>Esc</p></td>
</tr>
<tr class="row-even"><td><p>\s</p></td>
<td><p>Literal semicolon</p></td>
</tr>
</tbody>
</table>
<p>On PicoBlaze-6 you can apply the output of these macros directly in a <a class="reference internal" href="language.html#inst-table"><span class="std std-ref">table</span></a> directive as follows:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">table</span> <span class="n">hello#</span><span class="p">,</span> <span class="mh">[dec2pbhex(cstr(`Hello\r\n&#39;))]</span>
<span class="c">; This expands to: table hello#, [48, 65, 6c, 6c, 6f, 0d, 0a, 00]</span>

<span class="k">table</span> <span class="n">hello2#</span><span class="p">,</span> <span class="mh">[dec2pbhex(estr(`Hello\r\n&#39;))]</span>
<span class="c">; This expands to: table hello2#, [48, 65, 6c, 6c, 6f, 0d, 0a]</span>
</pre></div>
</div>
<p>For PicoBlaze-3 you can pass the output of <a class="reference internal" href="library.html#pb.estr" title="estr"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">estr()</span></code></a> and <a class="reference internal" href="library.html#pb.cstr" title="cstr"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">cstr()</span></code></a> to the <a class="reference internal" href="library.html#pb.calltable" title="calltable"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">calltable()</span></code></a>, <a class="reference internal" href="library.html#pb.storetable" title="storetable"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">storetable()</span></code></a>, and <a class="reference internal" href="library.html#pb.outputtable" title="outputtable"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">outputtable()</span></code></a> macros or use the portable string macros described next.</p>
<p>If you need to know the length of a string constant you can use <a class="reference internal" href="library.html#pb.strlenc" title="strlenc"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">strlenc()</span></code></a> to generate that value. It takes a single string argument that can contain escaped characters. It is passed through <a class="reference internal" href="library.html#pb.estr" title="estr"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">estr()</span></code></a> to remove escapes before characters are counted. <a class="reference internal" href="library.html#pb.strlenc" title="strlenc"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">strlenc()</span></code></a> only works at compile time when passed a string literal or a named portable/packed string. It does not work at runtime on dynamic string buffers.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="nb">strlenc(</span><span class="s">`foobar\r\n&#39;</span><span class="nb">)</span> <span class="c">; Expands to 8</span>
</pre></div>
</div>
<p>You can also pass the label to a string defined with <code class="xref pb pb-macro docutils literal notranslate"><span class="pre">string()</span></code> or <code class="xref pb pb-macro docutils literal notranslate"><span class="pre">packed_string()</span></code> to retrieve their length.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">packed_string(</span><span class="s">my_string</span><span class="p">,</span> <span class="s">`This</span> <span class="s">is</span> <span class="s">a</span> <span class="s">string&#39;</span><span class="nb">)</span>
<span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="nb">strlenc(</span><span class="s">my_string</span><span class="nb">)</span> <span class="c">; Expands to 16</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>m4 has a builtin macro <code class="docutils literal notranslate"><span class="pre">len()</span></code> that also returns the length of strings. However, it does not account for escape characters and will include blackslashes in its count.</p>
</div>
</section>
<section id="portable-strings">
<span id="portable-string-and-table-operations"></span><h3>Portable strings<a class="headerlink" href="#portable-strings" title="Permalink to this heading">¶</a></h3>
<p>A simplified system for generating efficient, portable strings is provided by the macro package. With this you can create string handling code that will expand into the most efficient form for PicoBlaze-3 or PicoBlaze-6 allowing you to easily migrate between platforms. You must first setup the portable string system with the <a class="reference internal" href="library.html#pb.use_strings" title="use_strings"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_strings()</span></code></a> macro. It configures the registers and a character handling routine used when processing a string.</p>
<p><a class="reference internal" href="library.html#pb.use_strings" title="use_strings"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_strings()</span></code></a> takes the following arguments:</p>
<ul class="simple">
<li><p>Arg1: Register loaded with each character</p></li>
<li><p>Arg2, Arg3: MSB, LSB of string address (Only used on PB6. Use dummy registers for PB3)</p></li>
<li><p>Arg4: Label of a user provided function called to process each character</p></li>
<li><p>Arg5: Optional name of the macro to define new strings (default is “string”)</p></li>
</ul>
<p>After configuring string handling with <a class="reference internal" href="library.html#pb.use_strings" title="use_strings"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_strings()</span></code></a> you must define each string using the <code class="xref pb pb-macro docutils literal notranslate"><span class="pre">string()</span></code> macro. It takes two arguments. The first is a label to identify the string and the second is the string. You can use any of the escapes supported by <a class="reference internal" href="library.html#pb.estr" title="estr"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">estr()</span></code></a> and <a class="reference internal" href="library.html#pb.cstr" title="cstr"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">cstr()</span></code></a> in a string. Strings are reproduced by calling them with the label used in their definition. Labels should not end with a “$” like with the <a class="reference internal" href="language.html#inst-string"><span class="std std-ref">string</span></a> directive.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">jump</span> <span class="n">main</span>
<span class="nb">use_strings(</span><span class="s">s0</span><span class="p">,</span> <span class="s">s5</span><span class="p">,</span><span class="s">s6</span><span class="p">,</span> <span class="s">write_char</span><span class="nb">)</span>

<span class="k">proc</span> <span class="nb">write_char(</span><span class="s">s0</span><span class="nb">)</span> {
  <span class="k">output</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">00</span>
<span class="p">}</span>

<span class="nb">string(</span><span class="s">hello</span><span class="p">,</span> <span class="s">`Hello</span> <span class="s">world\r\n&#39;</span><span class="nb">)</span> <span class="c">; Define a string called &quot;hello&quot;</span>

<span class="nl">main:</span>
...
<span class="k">call</span> <span class="n">hello</span> <span class="c">; Call write_char on each character in the &quot;hello&quot; string</span>
</pre></div>
</div>
<p>This expands to the following when targeting PB6:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span>                  <span class="k">JUMP</span> <span class="n">main</span>
                  <span class="c">; PB6 common string handler routine</span>
<span class="nl">__string_handler:</span> <span class="k">CALL@</span> <span class="p">(</span><span class="n">s5</span><span class="p">,</span> <span class="n">s6</span><span class="p">)</span>                 <span class="c">; Read next char</span>
                  <span class="k">COMPARE</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">00</span>                 <span class="c">; Check if NUL</span>
                  <span class="k">RETURN</span> <span class="n">z</span>
                  <span class="k">CALL</span> <span class="n">write_char</span>                <span class="c">; Handle the char</span>
                  <span class="k">ADD</span> <span class="n">s6</span><span class="p">,</span> <span class="mh">01</span>                     <span class="c">; 1</span>
                  <span class="k">ADDCY</span> <span class="n">s5</span><span class="p">,</span> <span class="mh">00</span>                   <span class="c">; Increment address</span>
                  <span class="k">JUMP</span> <span class="n">__string_handler</span>

                  <span class="cs">;PRAGMA function write_char [s0] begin</span>
      <span class="nl">write_char:</span>
                  <span class="k">OUTPUT</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">00</span>
                  <span class="k">RETURN</span>
                  <span class="cs">;PRAGMA function write_char end</span>

                  <span class="c">; &quot;Hello world\r\n&quot;</span>
                  <span class="k">TABLE</span> <span class="n">hello#</span><span class="p">,</span> <span class="mh">[48, 65, 6c, 6c, 6f, 20, 77, 6f, 72, 6c, 64, 0d, 0a, 00]</span>
           <span class="nl">hello:</span> <span class="k">LOAD</span> <span class="n">s5</span><span class="p">,</span> <span class="n">_hello_STR</span><span class="o">&#39;upper</span>
                  <span class="k">LOAD</span> <span class="n">s6</span><span class="p">,</span> <span class="n">_hello_STR</span><span class="o">&#39;lower</span>
                  <span class="k">JUMP</span> <span class="n">__string_handler</span>
      <span class="nl">_hello_STR:</span> <span class="k">LOAD&amp;RETURN</span> <span class="n">s0</span><span class="p">,</span> <span class="n">hello#</span>         <span class="c">; Define a string called `&quot;hello&quot;&#39;</span>

            <span class="nl">main:</span>
                  ...
                  <span class="k">CALL</span> <span class="n">hello</span>                     <span class="c">; Call write_char on each character in the &quot;hello&quot; string</span>
</pre></div>
</div>
<p>Note that a common string processing routine <code class="docutils literal notranslate"><span class="pre">__string_handler</span></code> is generated after the call to <code class="docutils literal notranslate"><span class="pre">jump</span> <span class="pre">main</span></code> and the escaped string is implemented with <a class="reference internal" href="language.html#inst-load-return"><span class="std std-ref">load&amp;return</span></a> instructions.</p>
<p>When targeting PB3 the following expansion results:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span>            <span class="k">JUMP</span> <span class="n">main</span>

            <span class="cs">;PRAGMA function write_char [s0] begin</span>
<span class="nl">write_char:</span>
            <span class="k">OUTPUT</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">00</span>
            <span class="k">RETURN</span>
            <span class="cs">;PRAGMA function write_char end</span>

            <span class="c">; &quot;Hello world\r\n&quot;</span>
     <span class="nl">hello:</span> <span class="k">LOAD</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">48</span>
            <span class="k">CALL</span> <span class="n">write_char</span>
            <span class="k">LOAD</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">65</span>
            <span class="k">CALL</span> <span class="n">write_char</span>
            <span class="k">LOAD</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">6c</span>
            <span class="k">CALL</span> <span class="n">write_char</span>
            <span class="k">LOAD</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">6c</span>
            <span class="k">CALL</span> <span class="n">write_char</span>
            ...
            <span class="k">LOAD</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">0d</span>
            <span class="k">CALL</span> <span class="n">write_char</span>
            <span class="k">LOAD</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">0a</span>
            <span class="k">CALL</span> <span class="n">write_char</span>
            <span class="k">RETURN</span>                         <span class="c">; Define a string called `&quot;hello&quot;&#39;</span>

      <span class="nl">main:</span>
            ...
            <span class="k">CALL</span> <span class="n">hello</span>                     <span class="c">; Call write_char on each character in the &quot;hello&quot; string</span>
</pre></div>
</div>
<p>The PB3 version does not generate a common handler routine but instead generates code to handle each string in place using the <a class="reference internal" href="library.html#pb.calltable" title="calltable"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">calltable()</span></code></a> macro.</p>
<p>You are limited to a single user provided function for processing each character in a string. If you need to perform different operations on strings then you will have to use a register or scratchpad value to select the desired behavior before calling the string label and write a handler routine that checks what operation is needed for each character it receives.</p>
</section>
<section id="packed-strings">
<h3>Packed strings<a class="headerlink" href="#packed-strings" title="Permalink to this heading">¶</a></h3>
<p>A set of macros for handling packed strings is available for use. These work similarly to the portable string macros but rely on character data packed with <a class="reference internal" href="language.html#inst-inst"><span class="std std-ref">inst</span></a> directives. This is the most efficient way to store uncompressed strings in PicoBlaze memory. Access to the data must be implemented with external hardware that can read instruction memory through a second port. The <code class="docutils literal notranslate"><span class="pre">picoblaze_dp_rom</span></code> component defined in <a class="reference external" href="https://github.com/kevinpt/opbasm/blob/master/templates/picoblaze_rom.vhdl">picoblaze_rom.vhdl</a> shows a way to accomplish that. The same code is generated for both PB3 and PB6.</p>
<p>To configure packed strings you need to call the <a class="reference internal" href="library.html#pb.use_packed_strings" title="use_packed_strings"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_packed_strings()</span></code></a> macro. It is similar to <a class="reference internal" href="library.html#pb.use_strings" title="use_strings"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_strings()</span></code></a> but you also need to provide a function that retrieves character pairs from an address in memory. Its arguments are the following:</p>
<ul class="simple">
<li><p>Arg1: Register to store even characters (0, 2, 4, …)</p></li>
<li><p>Arg2: Register to store odd characters  (1, 3, 5, …)</p></li>
<li><p>Arg3, Arg4: Registers for MSB, LSB of address to string</p></li>
<li><p>Arg5: Label of user provided function called to process each character (Only needs to handle the even char register)</p></li>
<li><p>Arg6: Label of user provided function called to read pairs of characters from memory</p></li>
<li><p>Arg7: Optional name of the macro to define new strings (default is “packed_string”)</p></li>
</ul>
<p>Character pairs are stored in big-endian order. The first character in a string is stored in the upper byte of an <a class="reference internal" href="language.html#inst-inst"><span class="std std-ref">inst</span></a> directive. The read routine takes a set of registers for the address of a packed character pair. It must retrieve the <code class="docutils literal notranslate"><span class="pre">INST</span></code> data at that location and load the upper byte into the even character register and lower byte in the odd character register.</p>
<p>A common handler routine <code class="docutils literal notranslate"><span class="pre">__packed_string_handler</span></code> is generated so you must ensure the execution path bypasses the generated code.</p>
<p>After configuration you define strings with the <code class="xref pb pb-macro docutils literal notranslate"><span class="pre">packed_string()</span></code> macro just as with the <code class="xref pb pb-macro docutils literal notranslate"><span class="pre">string()</span></code> macro.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">jump</span> <span class="n">main</span>
<span class="nb">mem16(</span><span class="s">P_ROM</span><span class="p">,</span> <span class="mh">0x0b</span><span class="p">,</span><span class="mh">0x0a</span><span class="nb">)</span>            <span class="c">; Define 16-bit port addresses for dual-ported ROM</span>
<span class="nb">use_packed_strings(</span><span class="s">s0</span><span class="p">,</span><span class="s">s1</span><span class="p">,</span> <span class="s">s5</span><span class="p">,</span><span class="s">s6</span><span class="p">,</span> <span class="s">write_char</span><span class="p">,</span> <span class="s">read_next_chars</span><span class="nb">)</span>

<span class="k">proc</span> <span class="nb">write_char(</span><span class="s">s0</span><span class="nb">)</span> {
  <span class="k">output</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">00</span>                    <span class="c">; Using register for even chars</span>
<span class="p">}</span>

<span class="k">proc</span> <span class="nb">read_next_chars(</span><span class="s">s0</span><span class="p">,</span><span class="s">s1</span><span class="p">,</span> <span class="s">s5</span><span class="p">,</span><span class="s">s6</span><span class="nb">)</span> {
            <span class="nb">output16(</span><span class="s">s5</span><span class="p">,</span><span class="s">s6</span><span class="p">,</span> <span class="s">P_ROM</span><span class="nb">)</span> <span class="c">; Select next address from second port</span>
            <span class="k">nop</span>
            <span class="nb">input16(</span><span class="s">s0</span><span class="p">,</span><span class="s">s1</span><span class="p">,</span> <span class="s">P_ROM</span><span class="nb">)</span>  <span class="c">; Read back upper and lower byte</span>
<span class="p">}</span>

<span class="nb">packed_string(</span><span class="s">hello</span><span class="p">,</span> <span class="s">`Hello</span> <span class="s">world\r\n&#39;</span><span class="nb">)</span> <span class="c">; Define a packed string called &quot;hello&quot;</span>

<span class="nl">main:</span>
...
<span class="k">call</span> <span class="n">hello</span> <span class="c">; Call write_char on each character in the &quot;hello&quot; string</span>
</pre></div>
</div>
<p>This expands to the following on both target processors:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span>            <span class="ge">&lt;Handler routines&gt;</span>

            <span class="c">; &quot;Hello world\r\n&quot;</span>
     <span class="nl">hello:</span> <span class="k">LOAD</span> <span class="n">s5</span><span class="p">,</span> <span class="n">_hello_STR</span><span class="o">&#39;upper</span>
            <span class="k">LOAD</span> <span class="n">s6</span><span class="p">,</span> <span class="n">_hello_STR</span><span class="o">&#39;lower</span>
            <span class="k">JUMP</span> <span class="n">__packed_string_handler</span>
<span class="nl">_hello_STR:</span> <span class="k">INST</span> <span class="mh">04865</span>
            <span class="k">INST</span> <span class="mh">06c6c</span>
            <span class="k">INST</span> <span class="mh">06f20</span>
            <span class="k">INST</span> <span class="mh">0776f</span>
            <span class="k">INST</span> <span class="mh">0726c</span>
            <span class="k">INST</span> <span class="mh">0640d</span>
            <span class="k">INST</span> <span class="mh">00a00</span>

            <span class="c">; Define a packed string called `&quot;hello&quot;&#39;</span>

      <span class="nl">main:</span>

            <span class="k">CALL</span> <span class="n">hello</span>
</pre></div>
</div>
<p>You can see that the 13 byte string is stored into 7 instruction words providing the densest string storage possible without resorting to compression.</p>
<p>If you have existing code using the portable string macros, you can convert it to use packed strings by changing the macro name with the optional seventh argument:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">use_packed_strings(</span><span class="s">s0</span><span class="p">,</span><span class="s">s1</span><span class="p">,</span> <span class="s">s5</span><span class="p">,</span><span class="s">s6</span><span class="p">,</span> <span class="s">write_char</span><span class="p">,</span> <span class="s">read_next_chars</span><span class="p">,</span> <span class="s">string</span><span class="nb">)</span>
</pre></div>
</div>
</section>
<section id="multi-function-strings">
<h3>Multi-function strings<a class="headerlink" href="#multi-function-strings" title="Permalink to this heading">¶</a></h3>
<p>Most of the previous string handling routines are hard-coded to use a single callback routine like <code class="docutils literal notranslate"><span class="pre">write_char</span></code> to process characters. This function does not need to be limited to just outputting data on a port. It also does not need to be limited to a single operation. You can use a register or scratchpad location to alter its behavior for different needs.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">constant</span> <span class="n">M_CHAR_MODE</span><span class="p">,</span> <span class="mh">00</span>
<span class="k">constant</span> <span class="n">P_CONSOLE</span><span class="p">,</span> <span class="mh">FF</span>

<span class="k">constant</span> <span class="n">CHAR_OUT</span><span class="p">,</span> <span class="mh">01</span>
<span class="k">constant</span> <span class="n">CHAR_COPY</span><span class="p">,</span> <span class="mh">02</span>


<span class="nb">use_strings(</span><span class="s">s0</span><span class="p">,</span> <span class="s">s5</span><span class="p">,</span><span class="s">s6</span><span class="p">,</span> <span class="s">handle_char</span><span class="nb">)</span>

<span class="k">proc</span> <span class="nb">handle_char(</span><span class="s">`s0</span> <span class="s">is</span> <span class="s">ch&#39;</span><span class="p">,</span> <span class="s">`sA</span> <span class="s">is</span> <span class="s">ptr&#39;</span><span class="nb">)</span> {
  <span class="k">fetch</span> <span class="n">_tempreg</span><span class="p">,</span> <span class="n">M_CHAR_MODE</span>
  <span class="nb">if(</span><span class="s">_tempreg</span> <span class="o">==</span> <span class="s">CHAR_COPY</span><span class="nb">)</span> <span class="p">{</span>
    <span class="c">; Store in a scratchpad buffer</span>
    <span class="k">store</span> <span class="n">ch</span><span class="p">,</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
    <span class="k">add</span> <span class="n">ptr</span><span class="p">,</span> <span class="mh">01</span>
  <span class="p">}</span> <span class="nb">else</span> <span class="p">{</span> <span class="c">; CHAR_OUT</span>
    <span class="c">; Write to console</span>
    <span class="k">output</span> <span class="n">ch</span><span class="p">,</span> <span class="n">P_CONSOLE</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">string(</span><span class="s">hello</span><span class="p">,</span> <span class="s">`Hello</span> <span class="s">again\n&#39;</span><span class="nb">)</span>

...

<span class="c">; Write string to a port</span>
<span class="nb">load_store(</span><span class="s">CHAR_OUT</span><span class="p">,</span> <span class="s">M_CHAR_MODE</span><span class="nb">)</span>
<span class="k">call</span> <span class="n">hello</span>

<span class="c">; Copy string to a scratchpad buffer</span>
<span class="nb">load_store(</span><span class="s">CHAR_COPY</span><span class="p">,</span> <span class="s">M_CHAR_MODE</span><span class="nb">)</span>
<span class="k">load</span> <span class="n">sA</span><span class="p">,</span> <span class="mh">10</span>  <span class="c">; Start address</span>
<span class="k">call</span> <span class="n">hello</span>
<span class="nb">load_store(</span><span class="s">NUL</span><span class="p">,</span> <span class="s">sA</span><span class="nb">)</span> <span class="c">; Write NUL to end of string buffer</span>
</pre></div>
</div>
</section>
</section>
<section id="scratchpad-memory-operations">
<span id="id6"></span><h2>Scratchpad memory operations<a class="headerlink" href="#scratchpad-memory-operations" title="Permalink to this heading">¶</a></h2>
<p>A set of routines are available for manipulating arrays in scratchpad memory. They are accessed by invoking a <code class="docutils literal notranslate"><span class="pre">use_XXX()</span></code> generator macro to create the functions with register allocations of your choice. All of these macros take an initial argument that is the name of the generated function. They all preserve their input and temporary registers on the stack unless reused for a return value.</p>
<section id="memset">
<h3>memset<a class="headerlink" href="#memset" title="Permalink to this heading">¶</a></h3>
<p>The <a class="reference internal" href="library.html#pb.use_memset" title="use_memset"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_memset()</span></code></a> macro creates a function that can set an array to a fixed value.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="c">;                 &lt;dest&gt; &lt;len&gt; &lt;init value&gt;</span>
<span class="nb">use_memset(</span><span class="s">memset</span><span class="p">,</span> <span class="s">s0</span><span class="p">,</span>     <span class="s">s1</span><span class="p">,</span>     <span class="s">s2</span><span class="nb">)</span>
...

<span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">20</span>  <span class="c">; Destination at 0x20 in scratchpad</span>
<span class="k">load</span> <span class="n">s1</span><span class="p">,</span> <span class="mh">05</span>  <span class="c">; 5 bytes in the array</span>
<span class="k">load</span> <span class="n">s2</span><span class="p">,</span> <span class="sc">&quot;A&quot;</span> <span class="c">; Value to initialize with</span>
<span class="k">call</span> <span class="n">memset</span>
</pre></div>
</div>
<p>After the call every byte of the array will be initialized to the contents of the value register.</p>
</section>
<section id="memcopy">
<h3>memcopy<a class="headerlink" href="#memcopy" title="Permalink to this heading">¶</a></h3>
<p><a class="reference internal" href="library.html#pb.use_memcopy" title="use_memcopy"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_memcopy()</span></code></a> creates a function to copy an array from one location to another in scratchpad.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="c">;                  &lt;source&gt; &lt;dest&gt; &lt;len&gt;</span>
<span class="nb">use_memcopy(</span><span class="s">memcopy</span><span class="p">,</span> <span class="s">s0</span><span class="p">,</span>      <span class="s">s1</span><span class="p">,</span>   <span class="s">s2</span><span class="nb">)</span>
...

<span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">20</span> <span class="c">; Source at 0x20</span>
<span class="k">load</span> <span class="n">s1</span><span class="p">,</span> <span class="mh">10</span> <span class="c">; Destination at 0x10</span>
<span class="k">load</span> <span class="n">s2</span><span class="p">,</span> <span class="mh">05</span> <span class="c">; Copy 5 bytes</span>
<span class="k">call</span> <span class="n">memcopy</span>
</pre></div>
</div>
<p>After the call the bytes from 0x10 to 0x14 contain the data copied from 0x20 to 0x24.</p>
</section>
<section id="memwrite">
<h3>memwrite<a class="headerlink" href="#memwrite" title="Permalink to this heading">¶</a></h3>
<p>The <a class="reference internal" href="library.html#pb.use_memwrite" title="use_memwrite"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_memwrite()</span></code></a> macro scans an array in scratchpad and writes the raw bytes to a fixed output port.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">constant</span> <span class="n">ConsolePort</span><span class="p">,</span> <span class="mh">FE</span>
<span class="c">;                    &lt;source&gt; &lt;len&gt; &lt;output port&gt;</span>
<span class="nb">use_memwrite(</span><span class="s">memwrite</span><span class="p">,</span> <span class="s">s0</span><span class="p">,</span>      <span class="s">s1</span><span class="p">,</span>   <span class="s">ConsolePort</span><span class="nb">)</span>

<span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">20</span> <span class="c">; Source array</span>
<span class="k">load</span> <span class="n">s1</span><span class="p">,</span> <span class="mh">05</span> <span class="c">; Writing 5 bytes</span>
<span class="k">call</span> <span class="n">memwrite</span>
</pre></div>
</div>
<p>This performs an output to port 0xFE for each of the bytes from 0x20 to 0x24.</p>
</section>
<section id="hexwrite">
<h3>hexwrite<a class="headerlink" href="#hexwrite" title="Permalink to this heading">¶</a></h3>
<p>Similar to <a class="reference internal" href="library.html#pb.use_memwrite" title="use_memwrite"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_memwrite()</span></code></a> is the <a class="reference internal" href="library.html#pb.use_hexwrite" title="use_hexwrite"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_hexwrite()</span></code></a> macro. It writes an array of bytes converted to ASCII hex values. This macro destructively modifies the global <code class="docutils literal notranslate"><span class="pre">_tempreg</span></code> register.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="c">;                    &lt;source&gt; &lt;len&gt; &lt;output port&gt;</span>
<span class="nb">use_hexwrite(</span><span class="s">hexwrite</span><span class="p">,</span> <span class="s">s0</span><span class="p">,</span>      <span class="s">s1</span><span class="p">,</span>  <span class="s">ConsolePort</span><span class="nb">)</span>
...

<span class="nb">load_store(</span><span class="mh">0x5A</span><span class="p">,</span> <span class="mh">0x20</span><span class="nb">)</span>
<span class="nb">load_store(</span><span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x21</span><span class="nb">)</span>
<span class="nb">load_store(</span><span class="mh">0x42</span><span class="p">,</span> <span class="mh">0x22</span><span class="nb">)</span>

<span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">20</span> <span class="c">; Source array</span>
<span class="k">load</span> <span class="n">s1</span><span class="p">,</span> <span class="mh">03</span> <span class="c">; Writing 3 bytes</span>
<span class="k">call</span> <span class="n">hexwrite</span>
</pre></div>
</div>
<p>This writes the string “5A1142” to the output port. Every byte expands into two hex digits.</p>
</section>
<section id="bcdwrite">
<h3>bcdwrite<a class="headerlink" href="#bcdwrite" title="Permalink to this heading">¶</a></h3>
<p>Another similar output routine is the <a class="reference internal" href="library.html#pb.use_bcdwrite" title="use_bcdwrite"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_bcdwrite()</span></code></a> macro. It writes an array to an output port but treats the bytes
as unpacked BCD digits. Each digit is converted to an ASCII digit before writing to the port. Any leading 0 digits
are skipped. Invalid BCD digits are not detected.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="c">;                    &lt;source&gt; &lt;len&gt; &lt;output port&gt;</span>
<span class="nb">use_bcdwrite(</span><span class="s">bcdwrite</span><span class="p">,</span> <span class="s">s0</span><span class="p">,</span>      <span class="s">s1</span> <span class="p">,</span> <span class="s">ConsolePort</span><span class="nb">)</span>
...

<span class="nb">load_store(</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x20</span><span class="nb">)</span>
<span class="nb">load_store(</span><span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x21</span><span class="nb">)</span>
<span class="nb">load_store(</span><span class="mh">0x05</span><span class="p">,</span> <span class="mh">0x22</span><span class="nb">)</span>

<span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">20</span> <span class="c">; Source array</span>
<span class="k">load</span> <span class="n">s1</span><span class="p">,</span> <span class="mh">03</span> <span class="c">; Writing 3 bytes</span>
<span class="k">call</span> <span class="n">bcdwrite</span>
</pre></div>
</div>
<p>This converts the array to ASCII characters and sends “15” to the output port. This is useful for printing the output from <code class="docutils literal notranslate"><span class="pre">int2bcd</span></code> described below.</p>
</section>
</section>
<section id="bcd-conversion">
<span id="id7"></span><h2>BCD conversion<a class="headerlink" href="#bcd-conversion" title="Permalink to this heading">¶</a></h2>
<p>A pair of generator macros create functions for converting between unsigned integers and unpacked BCD. They are designed to work with arbitrary sized integers consisting of one or more bytes. The <a class="reference internal" href="library.html#pb.use_int2bcd" title="use_int2bcd"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_int2bcd()</span></code></a> macro takes a list of integer bytes on the stack and writes the BCD representation into a fixed size buffer.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="c">;             &lt;fixed array len&gt; &lt;dest&gt; &lt;integer bytes&gt; &lt;temp regs&gt;</span>
<span class="nb">use_int2bcd(</span><span class="s">int2bcd</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span>           <span class="s">s0</span><span class="p">,</span>       <span class="s">s1</span><span class="p">,</span>        <span class="s">s2</span><span class="p">,</span><span class="s">s3</span><span class="p">,</span><span class="s">s4</span><span class="p">,</span><span class="s">s5</span><span class="nb">)</span>
...

<span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">20</span>  <span class="c">; Use buffer from 0x20 to 0x24</span>
<span class="k">load</span> <span class="n">s1</span><span class="p">,</span> <span class="mh">02</span>  <span class="c">; Convert 16-bit integer (2 bytes)</span>
<span class="nb">load16(</span><span class="s">s4</span><span class="p">,</span><span class="s">s3</span><span class="p">,</span> <span class="m">30789</span><span class="nb">)</span>
<span class="nb">push(</span><span class="s">s3</span><span class="p">,</span> <span class="s">s4</span><span class="nb">)</span> <span class="c">; Place integer on stack low byte first, high byte last (on top)</span>
<span class="k">call</span> <span class="n">int2bcd</span>
</pre></div>
</div>
<p>After conversion the array at scratchpad 0x20 contains the hex values <code class="docutils literal notranslate"><span class="pre">[03</span> <span class="pre">00</span> <span class="pre">07</span> <span class="pre">08</span> <span class="pre">09]</span></code>. This result can then be processed by <code class="docutils literal notranslate"><span class="pre">bcdwrite</span></code> to write an integer value out to a port. The result is right justified in the array with leading 0’s for any unused digits. No error detection is performed if the result requires more digits than the generator macro was defined to use.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">load16(</span><span class="s">s4</span><span class="p">,</span><span class="s">s3</span><span class="p">,</span> <span class="m">512</span><span class="nb">)</span>
<span class="nb">push(</span><span class="s">s3</span><span class="p">,</span> <span class="s">s4</span><span class="nb">)</span>
<span class="k">call</span> <span class="n">int2bcd</span>
</pre></div>
</div>
<p>The result is <code class="docutils literal notranslate"><span class="pre">[00</span> <span class="pre">00</span> <span class="pre">05</span> <span class="pre">01</span> <span class="pre">12]</span></code> at 0x20.</p>
<p>For converting numeric string inputs to binary, a pair of generator macros can be used. First is <a class="reference internal" href="library.html#pb.use_ascii2bcd" title="use_ascii2bcd"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_ascii2bcd()</span></code></a> which will convert a numeric ASCII string into BCD format.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="c">;                    &lt;Array addr&gt; &lt;len&gt;</span>
<span class="nb">use_ascii2bcd(</span><span class="s">ascii2bcd</span><span class="p">,</span> <span class="s">s0</span><span class="p">,</span>        <span class="s">s1</span><span class="nb">)</span>

<span class="nb">load_store(</span><span class="s">&quot;X&quot;</span><span class="p">,</span> <span class="mh">0x20</span><span class="nb">)</span> <span class="c">; Simulate text input</span>
<span class="nb">load_store(</span><span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="mh">0x21</span><span class="nb">)</span>
<span class="nb">load_store(</span><span class="s">&quot;2&quot;</span><span class="p">,</span> <span class="mh">0x22</span><span class="nb">)</span>
<span class="nb">load_store(</span><span class="s">&quot;4&quot;</span><span class="p">,</span> <span class="mh">0x23</span><span class="nb">)</span>
<span class="nb">load_store(</span><span class="s">&quot;9&quot;</span><span class="p">,</span> <span class="mh">0x24</span><span class="nb">)</span>

<span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">20</span> <span class="c">; Use array at 0x20</span>
<span class="k">load</span> <span class="n">s1</span><span class="p">,</span> <span class="mh">05</span> <span class="c">; Convert 5 characters from 0x20 to 0x24</span>
<span class="k">call</span> <span class="n">ascii2bcd</span>
</pre></div>
</div>
<p>The resulting array contains BCD: <code class="docutils literal notranslate"><span class="pre">[00</span> <span class="pre">01</span> <span class="pre">02</span> <span class="pre">04</span> <span class="pre">09]</span></code>. Any non-digit characters in the string are converted to 0.</p>
<p>The <a class="reference internal" href="library.html#pb.use_bcd2int" title="use_bcd2int"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_bcd2int()</span></code></a> macro is used to convert from BCD to an integer. This finishes the conversion of numeric string input into a usable integer value after first converting ASCII to BCD using <a class="reference internal" href="library.html#pb.use_ascii2bcd" title="use_ascii2bcd"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">ascii2bcd</span></code></a>.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="c">;                &lt;Array addr&gt; &lt;len&gt; &lt;temp regs&gt;</span>
<span class="nb">use_bcd2int(</span><span class="s">bcd2int</span><span class="p">,</span> <span class="s">s0</span><span class="p">,</span>       <span class="s">s1</span><span class="p">,</span>   <span class="s">s2</span><span class="p">,</span><span class="s">s3</span><span class="p">,</span><span class="s">s4</span><span class="p">,</span><span class="s">s5</span><span class="p">,</span><span class="s">s6</span><span class="nb">)</span>

<span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">20</span> <span class="c">; Use array at 0x20</span>
<span class="k">load</span> <span class="n">s1</span><span class="p">,</span> <span class="mh">05</span> <span class="c">; Convert 5 digits from 0x20 to 0x24</span>
<span class="k">call</span> <span class="n">bcd2int</span>
</pre></div>
</div>
<p>The converted integer value is overwritten into the array from left to right, destroying some of the BCD digits. The first byte in the array is the least significant. The total number of converted binary integer bytes is returned in the length register (s1 in this case). After conversion the array contains <code class="docutils literal notranslate"><span class="pre">[E1</span> <span class="pre">04</span> <span class="pre">02</span> <span class="pre">04</span> <span class="pre">09]</span></code>. 0x04E1 is 1249 from the original ASCII string. The integer result is guaranteed to always be smaller than the largest BCD number that will fit in an array (999…) so an overflow is impossible.</p>
</section>
<section id="bit-arithmetic">
<h2>8-bit arithmetic<a class="headerlink" href="#bit-arithmetic" title="Permalink to this heading">¶</a></h2>
<p>The <a class="reference internal" href="library.html#pb.not" title="not"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">not()</span></code></a> and <a class="reference internal" href="library.html#pb.negate" title="negate"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">negate()</span></code></a> macros are available to perform logical inversion and 2’s complement negation on 8-bit registers. The <a class="reference internal" href="library.html#pb.abs" title="abs"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">abs()</span></code></a> macro produces the absolute value of signed registers.</p>
<p>You can perform signed comparison with the <a class="reference internal" href="library.html#pb.compares" title="compares"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">compares()</span></code></a> macro. It takes the same arguments as the native <a class="reference internal" href="language.html#inst-compare"><span class="std std-ref">compare</span></a> instruction. The <code class="docutils literal notranslate"><span class="pre">C</span></code> flag is set in accordance with their signed relationship. However, the <code class="docutils literal notranslate"><span class="pre">Z</span></code> flag is not set correctly. Use the <a class="reference internal" href="language.html#inst-compare"><span class="std std-ref">compare</span></a> instruction to test for equality or inequality of signed values.</p>
<p>If you need to convert an 8-bit signed value to 16-bit, use the <a class="reference internal" href="library.html#pb.signex" title="signex"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">signex(MSB,</span> <span class="pre">LSB)</span></code></a> macro to extend the sign bit onto the upper register. The 8-bit register to be extended is passed in as the LSB argument.</p>
</section>
<section id="bit-arithmetic-logical-and-shift-operators">
<span id="id8"></span><h2>16-bit arithmetic<a class="headerlink" href="#bit-arithmetic-logical-and-shift-operators" title="Permalink to this heading">¶</a></h2>
<p>The need will frequently arise to handle values larger than the capacity of an 8-bit register. The following macros provide quick access to 16-bit operations.</p>
<p>You can define aliases for pairs of 8-bit registers with <a class="reference internal" href="library.html#pb.reg16" title="reg16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">reg16()</span></code></a> and then pass them into the 16-bit arithmetic macros:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">reg16(</span><span class="s">rx</span><span class="p">,</span> <span class="s">s4</span><span class="p">,</span> <span class="s">s3</span><span class="nb">)</span>      <span class="c">; Virtual 16-bit register rx is composed of (s4, s3)</span>
<span class="nb">reg16(</span><span class="s">ry</span><span class="p">,</span> <span class="s">s6</span><span class="p">,</span> <span class="s">s5</span><span class="nb">)</span>

<span class="nb">load16(</span><span class="s">rx</span><span class="p">,</span> <span class="m">1000</span><span class="nb">)</span>
<span class="nb">load16(</span><span class="s">ry</span><span class="p">,</span> <span class="m">3000</span> <span class="o">+</span> <span class="m">500</span><span class="nb">)</span> <span class="c">; You can use arbitrary expressions for constants</span>
<span class="nb">add16(</span><span class="s">rx</span><span class="p">,</span> <span class="s">ry</span><span class="nb">)</span>          <span class="c">; rx = rx + ry</span>
<span class="nb">add16(</span><span class="s">rx</span><span class="p">,</span> <span class="o">-</span><span class="m">100</span><span class="nb">)</span>        <span class="c">; rx = rx + (-100)</span>
</pre></div>
</div>
<p>This is much less obtuse than manually calculating 16-bit constants and repeatedly implementing the operations in pieces. The virtual name always expands into its original two registers and can be used on any macro that takes an MSB,LSB register pair as an argument.</p>
<p>You can retrieve the upper and lower byte registers indirectly from a virtual name with the <a class="reference internal" href="library.html#pb.regupper" title="regupper"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">regupper()</span></code></a> and <a class="reference internal" href="library.html#pb.reglower" title="reglower"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">reglower()</span></code></a> macros. This makes it easy to reallocate the registers if needed.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="nb">reglower(</span><span class="s">rx</span><span class="nb">)</span> <span class="c">; s0 = s3</span>
<span class="k">load</span> <span class="n">s1</span><span class="p">,</span> <span class="nb">regupper(</span><span class="s">rx</span><span class="nb">)</span> <span class="c">; s1 = s4</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="library.html#pb.mem16" title="mem16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">mem16()</span></code></a> macro defines 16-bit constants for scratchpad and port addresses. Like <a class="reference internal" href="library.html#pb.reg16" title="reg16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">reg16()</span></code></a> it creates a new m4 macro that lets you refer to the pair of port addresses together. In addition, two constants are created with the same name suffixed with “_H” and “_L” to identify the high and low ports respectively.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">mem16(</span><span class="s">M_DATA</span><span class="p">,</span> <span class="mh">0x05</span><span class="p">,</span> <span class="mh">0x04</span><span class="nb">)</span>
<span class="nb">load16(</span><span class="s">rx</span><span class="p">,</span> <span class="m">1000</span><span class="nb">)</span>
<span class="nb">store16(</span><span class="s">rx</span><span class="p">,</span> <span class="s">M_DATA</span><span class="nb">)</span>
</pre></div>
</div>
<p>The following 16-bit functions are available. All other than <a class="reference internal" href="library.html#pb.not16" title="not16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">not16()</span></code></a>, <a class="reference internal" href="library.html#pb.negate16" title="negate16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">negate16()</span></code></a>, and <a class="reference internal" href="library.html#pb.abs16" title="abs16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">abs16()</span></code></a> take a constant or a 16-bit register as their second argument.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="library.html#pb.load16" title="load16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">load16()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.reg16" title="reg16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">reg16()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.mem16" title="mem16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">mem16()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.add16" title="add16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">add16()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="library.html#pb.sub16" title="sub16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">sub16()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.and16" title="and16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">and16()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.or16" title="or16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">or16()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.xor16" title="xor16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">xor16()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="library.html#pb.test16" title="test16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">test16()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.not16" title="not16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">not16()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.negate16" title="negate16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">negate16()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.abs16" title="abs16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">abs16()</span></code></a></p></td>
</tr>
</tbody>
</table>
<p>The <a class="reference internal" href="library.html#pb.test16" title="test16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">test16()</span></code></a> macro is implemented differently on PicoBlaze-3 due to the lack of the <a class="reference internal" href="language.html#inst-testcy"><span class="std std-ref">testcy</span></a> instruction. The <code class="docutils literal notranslate"><span class="pre">Z</span></code> flag is set when the AND of both bytes with the test word is zero but the <code class="docutils literal notranslate"><span class="pre">C</span></code> flag does not represent the XOR of all 16 bits.</p>
<p>A full suite of 16-bit shifts and rotates are also available. They work the same as their 8-bit equivalents.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="library.html#pb.sl0_16" title="sl0_16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">sl0_16()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.sl1_16" title="sl1_16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">sl1_16()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.sla_16" title="sla_16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">sla_16()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.slx_16" title="slx_16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">slx_16()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="library.html#pb.sr0_16" title="sr0_16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">sr0_16()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.sr1_16" title="sr1_16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">sr1_16()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.sra_16" title="sra_16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">sra_16()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.srx_16" title="srx_16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">srx_16()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="library.html#pb.rl16" title="rl16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">rl16()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.rr16" title="rr16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">rr16()</span></code></a></p></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">sl0_16(</span><span class="s">rx</span><span class="p">,</span> <span class="m">4</span><span class="nb">)</span> <span class="c">; Multiply by 2**4</span>
</pre></div>
</div>
</section>
<section id="bit-io">
<span id="bit-i-o-operations"></span><h2>16-bit IO<a class="headerlink" href="#bit-io" title="Permalink to this heading">¶</a></h2>
<p>16-bit versions of the port and scratchpad I/O operations are available. You can use the <a class="reference internal" href="library.html#pb.mem16" title="mem16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">mem16()</span></code></a> macro to define pairs of memory and port addresses for simplification. The variants using a pointer register increment by two so that successive calls can be made to work on contiguous ranges of addresses.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="library.html#pb.fetch16" title="fetch16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">fetch16()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.store16" title="store16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">store16()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.input16" title="input16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">input16()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.output16" title="output16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">output16()</span></code></a></p></td>
</tr>
</tbody>
</table>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">mem16(</span><span class="s">M_ACCUM</span><span class="p">,</span> <span class="mh">0x1b</span><span class="p">,</span> <span class="mh">0x1a</span><span class="nb">)</span>
<span class="nb">reg16(</span><span class="s">rx</span><span class="p">,</span> <span class="s">s4</span><span class="p">,</span> <span class="s">s3</span><span class="nb">)</span>

<span class="nb">fetch16(</span><span class="s">rx</span><span class="p">,</span> <span class="s">M_ACCUM</span><span class="nb">)</span>  <span class="c">; Fetch direct from address</span>

<span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="n">M_ACCUM_L</span>    <span class="c">; Low byte constant defined by mem16()</span>
<span class="nb">fetch16(</span><span class="s">rx</span><span class="p">,</span> <span class="s">s0</span><span class="nb">)</span>       <span class="c">; Fetch from indirect pointer</span>
<span class="nb">fetch16(</span><span class="s">rx</span><span class="p">,</span> <span class="s">s0</span><span class="nb">)</span>       <span class="c">; Fetch next word</span>
</pre></div>
</div>
<p>Similarly for port I/O.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">mem16(</span><span class="s">P_ACCUM</span><span class="p">,</span> <span class="mh">0x1b</span><span class="p">,</span> <span class="mh">0x1a</span><span class="nb">)</span>

<span class="nb">input16(</span><span class="s">rx</span><span class="p">,</span> <span class="s">P_ACCUM</span><span class="nb">)</span>  <span class="c">; Input direct from address</span>

<span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="n">P_ACCUM_L</span>
<span class="nb">input16(</span><span class="s">rx</span><span class="p">,</span> <span class="s">s0</span><span class="nb">)</span>       <span class="c">; Input from indirect pointer</span>
<span class="nb">input16(</span><span class="s">rx</span><span class="p">,</span> <span class="s">s0</span><span class="nb">)</span>       <span class="c">; Input next word</span>
</pre></div>
</div>
</section>
<section id="multiply-and-divide">
<span id="multiply-and-divide-routines"></span><h2>Multiply and divide<a class="headerlink" href="#multiply-and-divide" title="Permalink to this heading">¶</a></h2>
<p>The general purpose PicoBlaze 8x8 multiply and divide routines are made available with arbitrary register allocations to suit your needs. A set of constant multiply and divide routines can also be generated for faster results than the general purpose functions. The following macros are available:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="library.html#pb.use_multiply8x8" title="use_multiply8x8"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_multiply8x8()</span></code></a></p></td>
<td><p>8x8-bit unsigned</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="library.html#pb.use_multiply8x8s" title="use_multiply8x8s"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_multiply8x8s()</span></code></a></p></td>
<td><p>8x8-bit signed</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="library.html#pb.use_multiply8x8su" title="use_multiply8x8su"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_multiply8x8su()</span></code></a></p></td>
<td><p>8-bit signed x 8-bit unsigned</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="library.html#pb.use_divide8x8" title="use_divide8x8"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_divide8x8()</span></code></a></p></td>
<td><p>8/8-bit unsigned</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="library.html#pb.use_divide8x8s" title="use_divide8x8s"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_divide8x8s()</span></code></a></p></td>
<td><p>8/8-bit signed</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="library.html#pb.use_divide16x8" title="use_divide16x8"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_divide16x8()</span></code></a></p></td>
<td><p>16/8-bit unsigned</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="library.html#pb.use_divide16x8s" title="use_divide16x8s"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_divide16x8s()</span></code></a></p></td>
<td><p>16/8-bit signed</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="library.html#pb.use_multiply8xk" title="use_multiply8xk"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_multiply8xk()</span></code></a></p></td>
<td><p>8-bit x constant</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="library.html#pb.use_multiply8xk_small" title="use_multiply8xk_small"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_multiply8xk_small()</span></code></a></p></td>
<td><p>8-bit x constant (result less than 256)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="library.html#pb.use_divide8xk" title="use_divide8xk"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_divide8xk()</span></code></a></p></td>
<td><p>8-bit / constant</p></td>
</tr>
</tbody>
</table>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nl">init:</span>
  ...
  <span class="k">jump</span> <span class="n">main</span> <span class="c">; Skip over our functions</span>

  <span class="c">; Configure multiply and divide functions (sE is a temp register)</span>
  <span class="nb">reg16(</span><span class="s">rx</span><span class="p">,</span> <span class="s">s5</span><span class="p">,</span> <span class="s">s4</span><span class="nb">)</span>
  <span class="nb">use_multiply8x8(</span><span class="s">mul8</span><span class="p">,</span> <span class="s">s0</span><span class="p">,</span> <span class="s">s1</span><span class="p">,</span> <span class="s">rx</span><span class="nb">)</span>     <span class="c">; rx = s0 * s1</span>

  <span class="nb">use_divide8x8(</span><span class="s">div8</span><span class="p">,</span> <span class="s">s0</span><span class="p">,</span> <span class="s">s1</span><span class="p">,</span> <span class="s">s6</span><span class="p">,</span> <span class="s">s7</span><span class="nb">)</span>   <span class="c">; s6 = s0 / s1  rem. s7</span>

  <span class="nb">use_multiply8xk(</span><span class="s">mul8k7</span><span class="p">,</span> <span class="s">s0</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="s">rx</span><span class="nb">)</span>        <span class="c">; rx = s0 * 7 (Multiplier can be greater than 255)</span>

  <span class="nb">use_multiply8xk_small(</span><span class="s">mul8k7s</span><span class="p">,</span> <span class="s">s0</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="s">s1</span><span class="nb">)</span> <span class="c">; s1 = s0 * 7 (Result must fit in one byte)</span>

  <span class="nb">use_divide8xk(</span><span class="s">div8k</span><span class="p">,</span> <span class="s">s0</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="s">s1</span><span class="nb">)</span>       <span class="c">; s1 = s0 / 7 (No remainder)</span>

<span class="nl">main:</span>

  <span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="m">20&#39;d</span>
  <span class="k">load</span> <span class="n">s1</span><span class="p">,</span> <span class="m">3&#39;d</span>
  <span class="k">call</span> <span class="n">mul8</span>    <span class="c">; rx = 20 * 3</span>

  <span class="k">call</span> <span class="n">div8</span>    <span class="c">; s6 = 20 / 3</span>

  <span class="k">call</span> <span class="n">mul8k7</span>  <span class="c">; rx = 20 * 7</span>

  <span class="k">call</span> <span class="n">mul8k7s</span> <span class="c">; s1 = 20 * 7</span>

  <span class="k">call</span> <span class="n">div8k</span>   <span class="c">; s1 = 20 / 7</span>
</pre></div>
</div>
</section>
<section id="expressions">
<span id="expression-parser"></span><h2>Expressions<a class="headerlink" href="#expressions" title="Permalink to this heading">¶</a></h2>
<p>A family of <a class="reference internal" href="library.html#pb.expr" title="expr"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">expression</span> <span class="pre">evaluator</span></code></a> macros are provided that can implement arithmetic and other operations using pseudo-infix notation. The basic principle is borrowed from the PL360 high level assembler. You can write an assignment expression of the form <code class="docutils literal notranslate"><span class="pre">expr(&lt;target</span> <span class="pre">register&gt;</span> <span class="pre">:=</span> <span class="pre">&lt;val&gt;</span> <span class="pre">op</span> <span class="pre">&lt;val&gt;</span> <span class="pre">[op</span> <span class="pre">&lt;val&gt;]*)</span></code>. Spaces are required between all symbols.</p>
<p><code class="docutils literal notranslate"><span class="pre">val</span></code> is one of:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>register</p></td>
</tr>
<tr class="row-even"><td><p>literal expression (with no internal spaces)</p></td>
</tr>
<tr class="row-odd"><td><p>“<cite>sp[&lt;addr&gt;]</cite>” reverse assignment to scratchpad address</p></td>
</tr>
<tr class="row-even"><td><p>“<cite>spi[&lt;reg&gt;]</cite>” reverse assignment to indirect scratchpad address in register</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">op</span></code> is one of:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>+, -, <cite>*</cite>, /</p></td>
<td><p>arithmetic: add, subtract, multiply, divide</p></td>
</tr>
<tr class="row-even"><td><p>&amp;, <cite>|</cite>, ^</p></td>
<td><p>bitwise operations: and, or, xor</p></td>
</tr>
<tr class="row-odd"><td><p>&lt;&lt;, &gt;&gt;</p></td>
<td><p>shifts: left and right</p></td>
</tr>
<tr class="row-even"><td><p>=:</p></td>
<td><p>reverse assignment</p></td>
</tr>
</tbody>
</table>
<p>Operations are evaluated from left to right with <em>no precedence</em>. The target register is used as the left operand of all operations. It is updated with the result after each operation.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">expr(</span><span class="s">s0</span> <span class="o">:=</span> <span class="s">s1</span> <span class="o">+</span> <span class="s">s2</span> <span class="o">=:</span> <span class="s">s3</span> <span class="o">&gt;&gt;</span> <span class="m">2</span><span class="nb">)</span>
</pre></div>
</div>
<p>Arithmetic is performed on <code class="docutils literal notranslate"><span class="pre">s0</span></code> at each stage. The reverse assignment to <code class="docutils literal notranslate"><span class="pre">s3</span></code> captures the intermediate result of <code class="docutils literal notranslate"><span class="pre">s1</span> <span class="pre">+</span> <span class="pre">s2</span></code> and then continues with the right shift applied to <code class="docutils literal notranslate"><span class="pre">s0</span></code>. This expands to:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="c">; Expression: s0 := s1 + s2 =: s3 &gt;&gt; 2</span>
<span class="k">LOAD</span> <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span>
<span class="k">ADD</span> <span class="n">s0</span><span class="p">,</span> <span class="n">s2</span>
<span class="k">LOAD</span> <span class="n">s3</span><span class="p">,</span> <span class="n">s0</span>
<span class="k">SR0</span> <span class="n">s0</span>
<span class="k">SR0</span> <span class="n">s0</span>
</pre></div>
</div>
<p>If you want to use the existing value of a register use it as the first operand after the assignment:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">load</span> <span class="n">s0</span><span class="p">,</span> <span class="mh">03</span>
<span class="nb">expr(</span><span class="s">s0</span> <span class="o">:=</span> <span class="s">s0</span> <span class="o">+</span> <span class="m">100</span><span class="nb">)</span>
</pre></div>
</div>
<p>Here are all of the expression macros available:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Macro</p></th>
<th class="head"><p>Target x Operand</p></th>
<th class="head"><p>Supported operators</p></th>
<th class="head"><p>Notes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="library.html#pb.expr" title="expr"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">expr()</span></code></a></p></td>
<td><p>8x8</p></td>
<td><p>+, -, <cite>*</cite>, /, &amp;, <cite>|</cite>, ^, &lt;&lt;, &gt;&gt;, =:</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="library.html#pb.exprs" title="exprs"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">exprs()</span></code></a></p></td>
<td><p>8x8</p></td>
<td><p>+, -, <cite>*</cite>, /, &amp;, <cite>|</cite>, ^, &lt;&lt;, &gt;&gt;, =:</p></td>
<td><p>signed <cite>*</cite>, /, and &gt;&gt;</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="library.html#pb.expr2" title="expr2"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">expr2()</span></code></a></p></td>
<td><p>16x8 <cite>*</cite></p></td>
<td><p>+, -, <cite>*</cite>, /, &lt;&lt;, &gt;&gt;, =:</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="library.html#pb.expr2s" title="expr2s"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">expr2s()</span></code></a></p></td>
<td><p>16x8 <cite>*</cite></p></td>
<td><p>+, -, <cite>*</cite>, /, &lt;&lt;, &gt;&gt;, =:</p></td>
<td><p>signed for all except &lt;&lt;</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="library.html#pb.expr16" title="expr16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">expr16()</span></code></a></p></td>
<td><p>16x16</p></td>
<td><p>+, -, &amp;, <cite>|</cite>, ^, &lt;&lt;, &gt;&gt;, =:</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="library.html#pb.expr16s" title="expr16s"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">expr16s()</span></code></a></p></td>
<td><p>16x16</p></td>
<td><p>+, -, &amp;, <cite>|</cite>, ^, &lt;&lt;, &gt;&gt;, =:</p></td>
<td><p>signed &gt;&gt;</p></td>
</tr>
</tbody>
</table>
<p><cite>*</cite> <em>The expr2 macros support 16-bit literals as operands of + and -. The first register after the assignment can be 16-bits.</em></p>
<p>16-bit registers must be comma separated register pairs in <code class="docutils literal notranslate"><span class="pre">MSB,LSB</span></code> order or named 16-bit registers created with <a class="reference internal" href="library.html#pb.reg16" title="reg16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">reg16()</span></code></a>.</p>
<p>For multiplication and division support you must initialize the internal functions with one of the following:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Macro</p></th>
<th class="head"><p>Multiply</p></th>
<th class="head"><p>Divide</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>expr</p></td>
<td><p><a class="reference internal" href="library.html#pb.use_expr_mul" title="use_expr_mul"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_expr_mul()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.use_expr_div" title="use_expr_div"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_expr_div()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>exprs</p></td>
<td><p><a class="reference internal" href="library.html#pb.use_expr_muls" title="use_expr_muls"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_expr_muls()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.use_expr_divs" title="use_expr_divs"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_expr_divs()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>expr2</p></td>
<td><p><a class="reference internal" href="library.html#pb.use_expr_mul" title="use_expr_mul"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_expr_mul()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.use_expr_div16" title="use_expr_div16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_expr_div16()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>expr2s</p></td>
<td><p><a class="reference internal" href="library.html#pb.use_expr_muls" title="use_expr_muls"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_expr_muls()</span></code></a> and <a class="reference internal" href="library.html#pb.use_expr_mulsu" title="use_expr_mulsu"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_expr_mulsu()</span></code></a></p></td>
<td><p><a class="reference internal" href="library.html#pb.use_expr_div16s" title="use_expr_div16s"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_expr_div16s()</span></code></a></p></td>
</tr>
</tbody>
</table>
<p>As an expedient you can invoke <a class="reference internal" href="library.html#pb.use_expr_all" title="use_expr_all"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_expr_all()</span></code></a> to include all of them and then eliminate any unused mul or div routines with the <code class="docutils literal notranslate"><span class="pre">--remove-dead-code</span></code> option to Opbasm.</p>
<p>These macros need to be called before any call to <code class="docutils literal notranslate"><span class="pre">expr*()</span></code> that uses multiplication or division. It is best to place them at the start of the program and jump over them to reach the startup code. The stack must be configured (<a class="reference internal" href="library.html#pb.use_stack" title="use_stack"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_stack()</span></code></a>) before calling these macros because additional modified registers must be saved and restored.</p>
<p>By default these macros configure the mul and div functions to use the <code class="docutils literal notranslate"><span class="pre">s8,s9</span></code> or <code class="docutils literal notranslate"><span class="pre">s7,s8,</span> <span class="pre">and</span> <span class="pre">s9</span></code> registers for input and output. You can modify the register allocation by passing arguments to the <code class="docutils literal notranslate"><span class="pre">use_*</span></code> macros. The registers <code class="docutils literal notranslate"><span class="pre">sA</span></code>, <code class="docutils literal notranslate"><span class="pre">sB</span></code>, and sometimes <code class="docutils literal notranslate"><span class="pre">sC</span></code> are temporarily altered and restored. The common temp register (default <code class="docutils literal notranslate"><span class="pre">sE</span></code>) is destructively modified. You can change the tempreg with the <a class="reference internal" href="library.html#pb.use_tempreg" title="use_tempreg"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_tempreg()</span></code></a> macro. The MSB of multiplication is ignored by subsequent operations. Division by 0 is not detected.</p>
<p>An example of signed expressions applied to converting temperatures:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="nb">use_stack(</span><span class="s">sF</span><span class="p">,</span> <span class="mh">0x3F</span><span class="nb">)</span>
<span class="k">jump</span> <span class="n">start</span>

<span class="k">use_expr_all</span> <span class="c">; Invoke all of the mul and div routines</span>

<span class="c">; Setup register aliases</span>
<span class="nb">reg16(</span><span class="s">rx</span><span class="p">,</span> <span class="s">s0</span><span class="p">,</span><span class="s">s1</span><span class="nb">)</span>
<span class="nb">reg16(</span><span class="s">ry</span><span class="p">,</span> <span class="s">s2</span><span class="p">,</span><span class="s">s3</span><span class="nb">)</span>
<span class="nb">vars(</span><span class="s">s4</span> <span class="s">is</span> <span class="s">celsius</span><span class="p">,</span> <span class="s">s5</span> <span class="s">is</span> <span class="s">fahrenheit</span><span class="nb">)</span>

<span class="c">; Convert temperature</span>
<span class="nl">c_to_f:</span>
  <span class="k">load</span> <span class="nb">reglower(</span><span class="s">rx</span><span class="nb">)</span><span class="p">,</span> <span class="n">celsius</span>     <span class="c">; Load 8-bit Celsius temperature</span>
  <span class="nb">signex(</span><span class="s">rx</span><span class="nb">)</span>                     <span class="c">; Sign extend to 16-bits</span>
  <span class="nb">expr2s(</span><span class="s">rx</span> <span class="o">:=</span> <span class="s">rx</span> <span class="o">*</span> <span class="m">9</span> <span class="o">/</span> <span class="m">5</span> <span class="o">+</span> <span class="m">32</span><span class="nb">)</span>  <span class="c">; Perform 16x8-bit signed arithmetic to get Fahrenheit</span>
  <span class="k">return</span>

<span class="nl">c_to_f_fast:</span> <span class="c">; Saves approx. 130 instructions compared to c_to_f with multiply</span>
  <span class="k">load</span> <span class="nb">reglower(</span><span class="s">ry</span><span class="nb">)</span><span class="p">,</span> <span class="n">celsius</span>     <span class="c">; Load 8-bit Celsius temperature</span>
  <span class="nb">signex(</span><span class="s">ry</span><span class="nb">)</span>                     <span class="c">; Sign extend to 16-bits</span>
  <span class="nb">expr16s(</span><span class="s">rx</span> <span class="o">:=</span> <span class="s">ry</span> <span class="o">&lt;&lt;</span> <span class="m">3</span> <span class="o">+</span> <span class="s">ry</span><span class="nb">)</span>    <span class="c">; Multiply by 9 with shift and add</span>
  <span class="nb">expr2s(</span><span class="s">rx</span> <span class="o">:=</span> <span class="s">rx</span> <span class="o">/</span> <span class="m">5</span> <span class="o">+</span> <span class="m">32</span><span class="nb">)</span>      <span class="c">; Perform 16x8-bit signed arithmetic to get Fahrenheit</span>
  <span class="k">return</span>

<span class="nl">f_to_c:</span>
  <span class="k">load</span> <span class="nb">reglower(</span><span class="s">rx</span><span class="nb">)</span><span class="p">,</span> <span class="n">fahrenheit</span>  <span class="c">; Load 8-bit Fahrenheit temperature</span>
  <span class="nb">signex(</span><span class="s">rx</span><span class="nb">)</span>                     <span class="c">; Sign extend to 16-bits</span>
  <span class="nb">expr2s(</span><span class="s">rx</span> <span class="o">:=</span> <span class="s">rx</span> <span class="o">-</span> <span class="m">32</span> <span class="o">*</span> <span class="m">5</span> <span class="o">/</span> <span class="m">9</span> <span class="nb">)</span> <span class="c">; Perform 16x8-bit signed arithmetic to get Celsius</span>
  <span class="k">return</span>

<span class="nl">start:</span>
  ...
</pre></div>
</div>
</section>
<section id="random-numbers">
<h2>Random numbers<a class="headerlink" href="#random-numbers" title="Permalink to this heading">¶</a></h2>
<p>A pair of simple pseudo-random number generators are included in the macro package. They are implemented using the xorshift algorithm with coefficients selected for minimal code on PicoBlaze. They generate a full cycle of every value in their range except 0. <a class="reference internal" href="library.html#pb.use_random8" title="use_random8"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_random8()</span></code></a> generates 8-bit numbers and <a class="reference internal" href="library.html#pb.use_random16" title="use_random16"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">use_random16()</span></code></a> generates 16-bit. You must set a non-zero seed value to initialize the PRNGs.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">namereg</span> <span class="n">sA</span><span class="p">,</span> <span class="n">SEED</span>
<span class="nb">use_random8(</span><span class="s">random</span><span class="p">,</span> <span class="s">SEED</span><span class="nb">)</span>
...
<span class="k">load</span> <span class="n">SEED</span><span class="p">,</span> <span class="mh">5A</span>    <span class="c">; You should use an entropy source to set the initial seed</span>
<span class="k">call</span> <span class="n">random</span>
...
<span class="k">call</span> <span class="n">random</span>
</pre></div>
</div>
<p>The new random value is in the <code class="docutils literal notranslate"><span class="pre">SEED</span></code> register after each call to <code class="docutils literal notranslate"><span class="pre">random</span></code>.</p>
<p>The 16-bit PRNG is similar but you must provide two additional registers for temporary values. Their contents are not preserved across calls.</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">namereg</span> <span class="n">sA</span><span class="p">,</span> <span class="n">SEEDH</span>
<span class="k">namereg</span> <span class="n">sB</span><span class="p">,</span> <span class="n">SEEDL</span>
<span class="nb">reg16(</span><span class="s">SEED</span><span class="p">,</span> <span class="s">SEEDH</span><span class="p">,</span><span class="s">SEEDL</span><span class="nb">)</span>
<span class="nb">use_random16(</span><span class="s">random</span><span class="p">,</span> <span class="s">SEED</span><span class="p">,</span> <span class="s">sC</span><span class="p">,</span><span class="s">sD</span><span class="nb">)</span>
...
<span class="nb">load16(</span><span class="s">SEED</span><span class="p">,</span> <span class="mh">0x1234</span><span class="nb">)</span>    <span class="c">; You should use an entropy source to set the initial seed</span>
<span class="k">call</span> <span class="n">random</span>
...
<span class="k">call</span> <span class="n">random</span>
</pre></div>
</div>
<p>If you don’t want to dedicate a register to storing the seed you can create a wrapper that fetches from scratchpad:</p>
<div class="highlight-picoblaze notranslate"><div class="highlight"><pre><span></span><span class="k">constant</span> <span class="n">M_SEED</span><span class="p">,</span> <span class="mh">00</span>  <span class="c">; Address to store seed variable</span>
<span class="nb">use_random8(</span><span class="s">random_core</span><span class="p">,</span> <span class="s">s0</span><span class="nb">)</span>

<span class="k">proc</span> <span class="nb">random(</span><span class="s">s0</span><span class="nb">)</span> {
  <span class="k">fetch</span> <span class="n">s0</span><span class="p">,</span> <span class="n">M_SEED</span>
  <span class="k">call</span> <span class="n">random_core</span>
  <span class="k">store</span> <span class="n">s0</span><span class="p">,</span> <span class="n">M_SEED</span>
<span class="p">}</span>

<span class="nb">load_store(</span><span class="s">M_SEED</span><span class="p">,</span> <span class="mh">0x5A</span><span class="nb">)</span>    <span class="c">; You should use an entropy source to set the initial seed</span>
...
<span class="k">call</span> <span class="n">random</span>
</pre></div>
</div>
</section>
<section id="miscellaneous">
<h2>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this heading">¶</a></h2>
<p>A few miscellaneous utility macros are included:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Macro</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Example</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="library.html#pb.nop" title="nop"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">nop()</span></code></a></p></td>
<td><p>No-operation</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="library.html#pb.clearcy" title="clearcy"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">clearcy()</span></code></a></p></td>
<td><p>Clear the carry flag</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="library.html#pb.setcy" title="setcy"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">setcy()</span></code></a></p></td>
<td><p>Set the carry flag</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">setcy</span> <span class="pre">or</span> <span class="pre">setcy(&lt;tmpreg&gt;)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="library.html#pb.isnum" title="isnum"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">isnum()</span></code></a></p></td>
<td><p>Test if a string is a number</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="library.html#pb.load_out" title="load_out"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">load_out()</span></code></a></p></td>
<td><p>Load and output value</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">load_out(0x01,</span> <span class="pre">P_uart)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="library.html#pb.load_store" title="load_store"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">load_store()</span></code></a></p></td>
<td><p>Load and store value</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">load_store(0x01,</span> <span class="pre">M_var)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="library.html#pb.reverse" title="reverse"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">reverse()</span></code></a></p></td>
<td><p>Reverse arguments</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">reverse(1,2,3)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="library.html#pb.swap" title="swap"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">swap()</span></code></a></p></td>
<td><p>Swap registers</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">swap(s0,</span> <span class="pre">s1)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="library.html#pb.randlabel" title="randlabel"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">randlabel()</span></code></a></p></td>
<td><p>Random label name</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">randlabel(PREFIX_)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="library.html#pb.uniqlabel" title="uniqlabel"><code class="xref pb pb-macro docutils literal notranslate"><span class="pre">uniqlabel()</span></code></a></p></td>
<td><p>Unique label name</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">uniqlabel(PREFIX_)</span></code></p></td>
</tr>
</tbody>
</table>
</section>
<section id="manually-running-m4">
<h2>Manually running m4<a class="headerlink" href="#manually-running-m4" title="Permalink to this heading">¶</a></h2>
<p>Some users may be unable to use Opbasm due to formal release procedures requiring a “golden” assembler. The m4 macro package can still be used with other PicoBlaze assemblers by manually running code through m4:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">&gt; m4 picoblaze.m4 [input source] &gt; expanded_macros.gen.psm</span>
</pre></div>
</div>
<p>The picoblaze.m4 file is located in the opbasm_lib directory of the source distribution.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/opbasm_logo.png" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">Opbasm</a></h1>



<p class="blurb">Advanced PicoBlaze Assembler</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=kevinpt&repo=opbasm&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="../index.html" title="previous chapter">Open PicoBlaze Assembler</a></li>
      <li>Next: <a href="language.html" title="next chapter">PicoBlaze architecture reference</a></li>
  </ul></li>
</ul>
</div>
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">m4 support in Opbasm</a><ul>
<li><a class="reference internal" href="#installing-m4-on-windows">Installing m4 on Windows</a></li>
<li><a class="reference internal" href="#overview-of-m4">Overview of m4</a></li>
<li><a class="reference internal" href="#type-conversions">Type conversions</a></li>
<li><a class="reference internal" href="#conditional-code">Conditional code</a></li>
<li><a class="reference internal" href="#general-purpose-macros">General purpose macros</a></li>
<li><a class="reference internal" href="#stack-operations">Stack operations</a></li>
<li><a class="reference internal" href="#bitfield-operations">Bitfield operations</a></li>
<li><a class="reference internal" href="#shift-and-rotate">Shift and rotate</a></li>
<li><a class="reference internal" href="#conditional-jump-call-and-return">Conditional jump call and return</a></li>
<li><a class="reference internal" href="#conditional-if-then-else">Conditional if-then-else</a><ul>
<li><a class="reference internal" href="#c-style-syntax">C-style syntax</a></li>
</ul>
</li>
<li><a class="reference internal" href="#looping">Looping</a><ul>
<li><a class="reference internal" href="#c-style-looping">C-style syntax</a></li>
</ul>
</li>
<li><a class="reference internal" href="#procedures-and-functions">Procedures and Functions</a><ul>
<li><a class="reference internal" href="#proc">proc</a></li>
<li><a class="reference internal" href="#func">func</a></li>
<li><a class="reference internal" href="#isr">isr</a></li>
</ul>
</li>
<li><a class="reference internal" href="#delay-generators">Delay generators</a><ul>
<li><a class="reference internal" href="#time-delays">Time delays</a></li>
<li><a class="reference internal" href="#variable-delays">Variable delays</a></li>
</ul>
</li>
<li><a class="reference internal" href="#string-and-table-operations">String and table operations</a><ul>
<li><a class="reference internal" href="#escaped-strings">Escaped strings</a></li>
<li><a class="reference internal" href="#portable-strings">Portable strings</a></li>
<li><a class="reference internal" href="#packed-strings">Packed strings</a></li>
<li><a class="reference internal" href="#multi-function-strings">Multi-function strings</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scratchpad-memory-operations">Scratchpad memory operations</a><ul>
<li><a class="reference internal" href="#memset">memset</a></li>
<li><a class="reference internal" href="#memcopy">memcopy</a></li>
<li><a class="reference internal" href="#memwrite">memwrite</a></li>
<li><a class="reference internal" href="#hexwrite">hexwrite</a></li>
<li><a class="reference internal" href="#bcdwrite">bcdwrite</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bcd-conversion">BCD conversion</a></li>
<li><a class="reference internal" href="#bit-arithmetic">8-bit arithmetic</a></li>
<li><a class="reference internal" href="#bit-arithmetic-logical-and-shift-operators">16-bit arithmetic</a></li>
<li><a class="reference internal" href="#bit-io">16-bit IO</a></li>
<li><a class="reference internal" href="#multiply-and-divide">Multiply and divide</a></li>
<li><a class="reference internal" href="#expressions">Expressions</a></li>
<li><a class="reference internal" href="#random-numbers">Random numbers</a></li>
<li><a class="reference internal" href="#miscellaneous">Miscellaneous</a></li>
<li><a class="reference internal" href="#manually-running-m4">Manually running m4</a></li>
</ul>
</li>
</ul>

  </div><h3>Other projects</h3>

<div id="proj_list">
<p>

<a href="http://kevinpt.github.io/ripyl/">Ripyl</a><br>
<a href="http://code.google.com/p/vertcl">Vertcl</a><br>
<a href="http://code.google.com/p/vhdl-extras">Vhdl-extras</a><br>
<a href="http://kevinpt.github.io/lecroy-colorizer/">Lecroy-colorizer</a>
</p>
</div>

<script>
$(function() { // Retrieve list of repositories from Github and dynamically insert them into sidebar

if(!window.sessionStorage || !JSON) { return; } // Punt on crusty browsers (looking at you IE10)

function JSONP( url, callback ) {
	var id = ( 'jsonp' + Math.random() * new Date() ).replace('.', '');
	var script = document.createElement('script');
	script.src = url.replace( 'callback=?', 'callback=' + id );
	document.body.appendChild( script );
	window[ id ] = function( data ) {
		if (callback) {
			callback( data );
		}
	};
}

// Build dictionary indexing lower cased project names with their preferred format
var knownProjects = ["VHDL-extras", "Ripyl", "VerTcl", "LeCroy-colorizer", "Opbasm"];
var projectDict = {};
$.each(knownProjects, function(index, v) {
  projectDict[v.toLowerCase()] = v;
});

function insert_projects(projects) {
    var links = [];
    var cur_proj = "Opbasm".toLowerCase();
    
    $.each(projects, function(key, value) {
      if(key != cur_proj) {
        var title;
        if(key in projectDict) {
          title = projectDict[key];
        } else { // Capitalize first char
          title = key.replace(/^./, function(match) {return match.toUpperCase()});
        }
        links.push("<a href='"+ value +"'>" + title + "</a>");
      }
    });
    
    $("#proj_list").html("<p>"+ links.join("<br>") +"</p>");
}

var now = new Date().getTime();
if(sessionStorage.KTcacheTime && now - sessionStorage.KTcacheTime < 5*60*1000 ) { // Use cached values (5 min. expiry)
  insert_projects(JSON.parse(sessionStorage.KTprojects));
} else { // Retrieve current projects
  JSONP("https://api.github.com/users/kevinpt/repos?type=owner&callback=?", function(response) {
    var projects = {};
    $.each(response.data, function(index, value) {
      if(!value.fork)
        projects[value.name] = value.homepage;
    });
    
    insert_projects(projects);
    
    // Store data in session cache
    sessionStorage.KTprojects = JSON.stringify(projects);
    var now = new Date().getTime();
    sessionStorage.KTcacheTime = now;
  });  
}

});
</script>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Kevin Thibedeau.
      
      |
      <a href="../_sources/rst/m4.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>